#	TextEditor - A syntax highlighting text editor for ImGui
#	Copyright (c) 1993-2025 Johan A. Goossens. All rights reserved.
#
#	This work is licensed under the terms of the MIT license.
#	For a copy, see <https://opensource.org/licenses/MIT>.


import datetime, fileinput, glob, os, re, sys


rangePattern = re.compile("([0-9A-F]+)\.\.([0-9A-F]+)")


header = '''//	Do not edit this file, it is automatically generated

//	TextEditor - A syntax highlighting text editor for ImGui
//	Copyright (c) 2024-2025 Johan A. Goossens. All rights reserved.
//
//	This work is licensed under the terms of the MIT license.
//	For a copy, see <https://opensource.org/licenses/MIT>.


//
//	Tables below are automatically generated from the unicode database version %s
//	downloaded from http://www.unicode.org/Public/UNIDATA/ on %s
//	using the Tables.py script.
//


//
//	Include files
//

#include <iterator>

#include "imgui.h"


//
//	Range table types
//

template <typename T>
struct Range {
	T low;
	T high;
	T stride;
};

using Range16 = Range<ImWchar16>;
using Range32 = Range<ImWchar32>;

template <typename T>
struct CaseRange {
	T low;
	T high;
	int32_t toUpper;
	int32_t toLower;
};

using CaseRange16 = CaseRange<char16_t>;
using CaseRange32 = CaseRange<char32_t>;
'''


footer = '''

//
//	rangeContains
//

template <typename T, typename C>
bool rangeContains(const T& table, C codepoint) {
	auto low = std::begin(table);
	auto high = std::end(table);

	while (low <= high) {
		auto mid = low + (high - low) / 2;

		if (codepoint >= mid->low && codepoint <= mid->high) {
			return (mid->stride == 1) || ((codepoint - mid->low) % mid->stride == 0);

		} else if (codepoint < mid->low) {
			high = mid - 1;

		} else {
			low = mid + 1;
		}
	}

	return false;
}


//
//	caseRangeFind
//

template <typename T, typename C>
const CaseRange<C>* caseRangeFind(const T& table, C codepoint) {
	auto low = std::begin(table);
	auto high = std::end(table);

	while (low <= high) {
		auto mid = low + (high - low) / 2;

		if (codepoint >= mid->low && codepoint <= mid->high) {
			return mid;

		} else if (codepoint < mid->low) {
			high = mid - 1;

		} else {
			low = mid + 1;
		}
	}

	return nullptr;
}


//
//	caseRangeToUpper
//

template <typename T, typename C>
C caseRangeToUpper(const T& table, C codepoint) {
	auto caseRange = caseRangeFind(table, codepoint);

	if (!caseRange || caseRange->toUpper == 0) {
		return codepoint;

	} else if (caseRange->toUpper == 0xffff) {
		return codepoint & ~0x1;
	}

	else {
		return codepoint + caseRange->toUpper;
	}
}


//
//	caseRangeToLower
//

template <typename T, typename C>
C caseRangeToLower(const T& table, C codepoint) {
	auto caseRange = caseRangeFind(table, codepoint);

	if (!caseRange || caseRange->toLower == 0) {
		return codepoint;

	} else if (caseRange->toLower == 0xffff) {
		return codepoint | 0x1;
	}

	else {
		return codepoint + caseRange->toLower;
	}
}
'''


def fetch(f):
	if not os.path.exists(os.path.basename(f)):
		os.system("curl -O http://www.unicode.org/Public/UNIDATA/%s" % f)

	if not os.path.exists(os.path.basename(f)):
		sys.stderr.write("cannot load %s" % f)
		exit(1)


def purge(dir, pattern):
	for f in glob.glob(pattern):
		os.remove(os.path.join(dir, f))


def buildRangeTable(input, filter):
	codepoints = []
	fetch(input)

	for text in fileinput.input(os.path.basename(input)):
		line = [entry.strip() for entry in text.split("#")[0].split(';')]

		if len(line) > 1 and filter(line):
			m = rangePattern.match(line[0])

			if m:
				for n in range(int(m.group(1), 16), int(m.group(2), 16) + 1):
					codepoints.append(n)

			else:
				codepoints.append(int(line[0], 16))

	codepoints = sorted(set(codepoints))
	ranges = []

	for codepoint in codepoints:
		ranges.append([codepoint, codepoint, 1])

	return ranges


def calculateStrides(table):
	result = []
	current = table.pop(0)

	while len(table):
		next = table.pop(0)
		stride = next[0] - current[1]

		if (next[0] == next[1] or stride == next[2]) and (current[0] == current[1] or stride == current[2]):
			current[1] = next[1]
			current[2] = stride

		elif stride == current[2]:
			current[1] = next[0]
			current[2] = stride
			next[0] = next[0] + next[2]

			if next[0] <= next[1]:
				result.append(current)
				current = next

		else:
			result.append(current)
			current = next

	result.append(current)
	return result


def createCaseRanges(input):
	result = []
	codepoints = []
	fetch(input)

	for text in fileinput.input(os.path.basename(input)):
		line = [entry.strip() for entry in text.split("#")[0].split(';')]

		if len(line) > 1:
			codepoint = int(line[0], 16)

			if line[2] == "Lu":
				if len(line[13]):
					result.append([codepoint, codepoint, 0, int(line[13], 16) - codepoint])

			elif line[2] == "Ll":
				if len(line[12]):
					result.append([codepoint, codepoint, int(line[12], 16) - codepoint, 0])

	return result


def compressCaseRanges(ranges):
	result = []
	current = ranges.pop(0)

	while len(ranges):
		next = ranges.pop(0)

		if next[0] == current[1] + 1 and next[2] == current[2] and next[3] == current[3]:
			current[1] = next[0]

		else:
			result.append(current)
			current = next

	result.append(current)
	return result


def compressUpperLower(ranges):
	result = []
	inAdjacent = False
	current = ranges.pop(0)
	start = end = 0

	while len(ranges):
		next = ranges.pop(0)

		if ((current[2] ==  0 and current[3] == 1 and next[2] == -1 and next[3] == 0) or
			(current[2] == -1 and current[3] == 0 and next[2] ==  0 and next[3] == 1)):

			if not inAdjacent:
				start = current[0]
				inAdjacent = True

			end = next[1]

		elif inAdjacent:
			result.append([start, end, 0xffff, 0xffff])
			inAdjacent = False

		else:
			result.append(current)

		current = next

	if inAdjacent:
		result.append([start, end, 0xffff, 0xffff])

	else:
		result.append(current)

	return result


def printTable(table, type, name, filter, format, conditional32bit):
	result = '''

//
//	%s
//

''' % name

	if conditional32bit:
		result += "#if defined(IMGUI_USE_WCHAR32)\n\n"

	result += "static %s %s[] = {\n" %(type, name)
	line = "\t"
	first = True

	for entry in table:
		if filter(entry):
			chunk = format(entry)

			if len(line) + len(chunk) < 120:
				if first:
					line += chunk
					first = False

				else:
					line += ", " + chunk

			else:
				result += line + ",\n"
				line = "\t" + chunk

	result += line + "\n};\n"

	if conditional32bit:
		result += "\n#endif\n"

	return result


if __name__ == "__main__":
	os.chdir(os.path.dirname(os.path.abspath(__file__)))

	fetch("ReadMe.txt")

	with open("ReadMe.txt") as readme:
		version = re.search("for Version (\d+\.\d+\.\d+) of the Unicode", readme.read()).group(1)

	with open("Tables.h", "w") as tables:
		tables.write(header % (version, datetime.datetime.now().strftime("%A, %B %d, %Y")))

		filter16 = lambda r : r[0] < 0x10000
		filter32 = lambda r : r[0] >= 0x10000
		formatStride = lambda r : ("{0x%04x, 0x%04x, 0x%04x}" if r[0] < 0x10000 else "{0x%05x, 0x%05x, 0x%04x}") % (r[0], r[1], r[2])
		formatCase = lambda r : ("{0x%04x, 0x%04x, %6d, %6d}" if r[0] < 0x10000 else "{0x%05x, 0x%05x, %3d, %2d}") % (r[0], r[1], r[2], r[3])

		letters = calculateStrides(buildRangeTable("UnicodeData.txt", lambda line : line[2][0] == "L"))
		tables.write(printTable(letters, "Range16", "letters16", filter16, formatStride, False))
		tables.write(printTable(letters , "Range32", "letters32", filter32, formatStride, True))

		lower = calculateStrides(buildRangeTable("UnicodeData.txt", lambda line : line[2] == "Ll"))
		tables.write(printTable(lower, "Range16", "lower16", filter16, formatStride, False))
		tables.write(printTable(lower , "Range32", "lower32", filter32, formatStride, True))

		upper = calculateStrides(buildRangeTable("UnicodeData.txt", lambda line : line[2] == "Lu"))
		tables.write(printTable(upper, "Range16", "upper16", filter16, formatStride, False))
		tables.write(printTable(upper, "Range32", "upper32", filter32, formatStride, True))

		numbers = calculateStrides(buildRangeTable("UnicodeData.txt", lambda line : line[2] == "Nd"))
		tables.write(printTable(numbers, "Range16", "numbers16", filter16, formatStride, False))
		tables.write(printTable(numbers, "Range32", "numbers32", filter32, formatStride, True))

		whitespace =calculateStrides( buildRangeTable("PropList.txt", lambda line : line[1] == "White_Space"))
		tables.write(printTable(whitespace, "Range16", "whitespace16", filter16, formatStride, False))

		xidStart = calculateStrides(buildRangeTable("DerivedCoreProperties.txt", lambda line : line[1] == "XID_Start"))
		tables.write(printTable(xidStart, "Range16", "xidStart16", filter16, formatStride, False))
		tables.write(printTable(xidStart, "Range32", "xidStart32", filter32, formatStride, True))

		xidContinue = calculateStrides(buildRangeTable("DerivedCoreProperties.txt", lambda line : line[1] == "XID_Continue"))
		tables.write(printTable(xidContinue, "Range16", "xidContinue16", filter16, formatStride, False))
		tables.write(printTable(xidContinue, "Range32", "xidContinue32", filter32, formatStride, True))

		caseRanges = compressUpperLower(compressCaseRanges(createCaseRanges("UnicodeData.txt")))
		tables.write(printTable(caseRanges, "CaseRange16", "case16", filter16, formatCase, False))
		tables.write(printTable(caseRanges, "CaseRange32", "case32", filter32, formatCase, True))

		tables.write(footer)
		purge(".", "*.txt")
