/* ============== Do not edit this file ============== */


//	TextEditor - A syntax highlighting text editor for Dear ImGui.
//	Copyright (c) 2024-2025 Johan A. Goossens. All rights reserved.
//
//	This work is licensed under the terms of the MIT license.
//	For a copy, see <https://opensource.org/licenses/MIT>.


//
//	getCsStyleNumber
//

static TextEditor::Iterator getCsStyleNumber(TextEditor::Iterator start, TextEditor::Iterator end) {
	TextEditor::Iterator i = start;
	TextEditor::Iterator marker;

	/*!re2c
		re2c:api = custom;
		re2c:api:style = free-form;
		re2c:define:YYCTYPE = ImWchar;
		re2c:define:YYPEEK = "i < end ? *i : 0";
		re2c:define:YYSKIP = "++i;";
		re2c:define:YYBACKUP = "marker = i;";
		re2c:define:YYRESTORE = "i = marker;";
		re2c:define:YYLESSTHAN = "i >= end";
		re2c:yyfill:enable = 0;
		re2c:eof = 0;

		D    = [0-9];							// decimal digit
		DD   = [0-9_];							// decorated decimal digit
		B    = [01];							// binary digit
		DB   = [01_];							// decorated binary digit
		H    = [a-fA-F0-9];						// hexadecimal digit
		DH   = [a-fA-F0-9_];					// decorated hexadecimal digit
		BP   = "0"[bB];							// binary integer prefix
		HP   = "0"[xX];							// hexadecimal integer prefix
		E    = [Ee][+-]?DD+;					// exponent
		FS   = [fFlL];							// float suffixes
		IS   = [uU]("l"|"L"|"ll"|"LL")? | ("l"|"L"|"ll"|"LL")[uU]?;

		D DD* IS?               { return i; }	// decimal integer
		BP B DB* IS?            { return i; }	// binary integer
		HP H DH* IS?            { return i; }	// hexadecimal integer
		"." D DD* E? FS?        { return i; }	// float
		D DD* "." D DD* E? FS?  { return i; }

		$ { return start; }
		* { return start; }
	*/
}


//
//	TextEditor::Language::Cs
//

const TextEditor::Language* TextEditor::Language::Cs() {
	static bool initialized = false;
	static TextEditor::Language language;

	if (!initialized) {
		language.name = "C#";
		language.preprocess = '#';
		language.singleLineComment = "//";
		language.commentStart = "/*";
		language.commentEnd = "*/";
		language.hasSingleQuotedStrings = true;
		language.hasDoubleQuotedStrings = true;
		language.stringEscape = '\\';

		static const char* const keywords[] = {
			"abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked", "class", "const", "continue",
			"decimal", "default", "delegate", "do", "double", "else", "enum", "event", "explicit", "extern", "false", "finally",
			"fixed", "float", "for", "foreach", "goto", "if", "implicit", "in", "in (generic modifier)", "int", "interface",
			"internal", "is", "lock", "long", "namespace", "new", "null", "object", "operator", "out", "override", "params",
			"private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed", "short", "sizeof", "stackalloc",
			"static", "string", "struct", "switch", "this", "throw", "true", "try", "typeof", "uint", "ulong", "unchecked",
			"unsafe", "ushort", "using", "using static", "void", "volatile", "while"
		};

		for (auto& keyword : keywords) { language.keywords.insert(keyword); }

		language.isPunctuation = isCStylePunctuation;
		language.getIdentifier = getCStyleIdentifier;
		language.getNumber = getCsStyleNumber;
		initialized = true;
	}

	return &language;
}
