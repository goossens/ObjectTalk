<!DOCTYPE html>
<html lang="en">
  <head>
    <title>ObjectTalk Architecture</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="fonts/font-awesome.min.css" />
    <link rel="stylesheet" type="text/css" href="css/theme.css" />
  </head>
  <body id="page-top">
    <div
      class="container-fluid d-flex flex-column flex-grow-1 vh-100 overflow-hidden"
    >
      <nav
        class="navbar navbar-expand px-0 pt-1 pb-0 flex-shrink-0 manual-header"
      >
        <a class="navbar-brand" href="index.html"
          ><img src="img/icon.png" height="40" alt="" /><span class="ml-2"
            >Documentation</span
          ></a
        ><button
          class="navbar-toggler navbar-toggler-right"
          data-toggle="collapse"
          data-target="#navbarResponsive"
          type="button"
          data-toogle="collapse"
          aria-controls="navbarResponsive"
          aria-expanded="false"
          aria-label="Toggle navigation"
        >
          <i class="fa fa-bars"></i>
        </button>
        <div class="collapse navbar-collapse" id="navbarResponsive">
          <ul class="navbar-nav ml-auto">
            <li class="nav-item dropdown">
              <a
                class="nav-link dropdown-toggle"
                href="#"
                id="General"
                role="button"
                data-toggle="dropdown"
                aria-haspopup="true"
                aria-expanded="false"
                >General</a
              >
              <div class="dropdown-menu" aria-labelledby="General">
                <a class="nav-link page-scroll" href="index.html"
                  >Introduction</a
                ><a class="nav-link page-scroll" href="architecture.html"
                  >Architecture</a
                ><a class="nav-link page-scroll" href="installation.html"
                  >Installation</a
                >
              </div>
            </li>
            <li class="nav-item dropdown">
              <a
                class="nav-link dropdown-toggle"
                href="#"
                id="Language"
                role="button"
                data-toggle="dropdown"
                aria-haspopup="true"
                aria-expanded="false"
                >Language</a
              >
              <div class="dropdown-menu" aria-labelledby="Language">
                <a class="nav-link page-scroll" href="tour.html">Tour</a
                ><a class="nav-link page-scroll" href="guide.html">Guide</a
                ><a class="nav-link page-scroll" href="language.html"
                  >Language</a
                ><a class="nav-link page-scroll" href="classes.html"
                  >Core Classes</a
                >
              </div>
            </li>
            <li class="nav-item dropdown">
              <a
                class="nav-link dropdown-toggle"
                href="#"
                id="Modules"
                role="button"
                data-toggle="dropdown"
                aria-haspopup="true"
                aria-expanded="false"
                >Modules</a
              >
              <div class="dropdown-menu" aria-labelledby="Modules">
                <a class="nav-link page-scroll" href="http.html">HTTP</a>
              </div>
            </li>
            <li class="nav-item dropdown">
              <a
                class="nav-link dropdown-toggle"
                href="#"
                id="Nodes"
                role="button"
                data-toggle="dropdown"
                aria-haspopup="true"
                aria-expanded="false"
                >Nodes</a
              >
              <div class="dropdown-menu" aria-labelledby="Nodes">
                <a class="nav-link page-scroll" href="nodes-overview.html"
                  >Overview</a
                ><a class="nav-link page-scroll" href="nodes-reference.html"
                  >Reference</a
                >
              </div>
            </li>
            <li class="nav-item dropdown">
              <a
                class="nav-link dropdown-toggle"
                href="#"
                id="Scenes"
                role="button"
                data-toggle="dropdown"
                aria-haspopup="true"
                aria-expanded="false"
                >Scenes</a
              >
              <div class="dropdown-menu" aria-labelledby="Scenes">
                <a class="nav-link page-scroll" href="scenes-overview.html"
                  >Overview</a
                ><a class="nav-link page-scroll" href="scenes-reference.html"
                  >Reference</a
                >
              </div>
            </li>
            <li class="nav-item">
              <a class="nav-link page-scroll" href="ide.html">IDE</a>
            </li>
          </ul>
        </div>
      </nav>
      <div class="row flex-grow-1 overflow-hidden vh-100">
        <div class="col-2 mh-100 overflow-auto py-2 manual-toc">
          <p><strong>ObjectTalk Architecture</strong></p>
          <ul>
            <li><a class="page-scroll" href="#overview">Overview</a></li>
            <li>
              <a class="page-scroll" href="#software">Software Architecture</a>
            </li>
            <li>
              <a class="page-scroll" href="#runtime">Runtime Architecture</a>
            </li>
          </ul>
        </div>
        <div class="col mh-100 overflow-auto py-2 manual-content">
          <div id="overview">
            <h1 class="pb-2">Architecture Overview</h1>
            <p>
              The ObjectTalk ecosystem was designed as a cross-platform
              capability. Today, ObjectTalk runs on MacOS, Linux and Windows
              thanks to a large number of great open source packages.
            </p>
            <p>
              The ObjectTalk ecosystem is contained in a single executable that
              embeds all modules and their resources into one unit. Originally,
              the design called for a small executable that would load shared
              modules/assets on demand. It was however decided not to continue
              with this approach as dealing with DLL hell on Windows, keeping
              versions synchronized and putting things all over the filesystem
              would lead to fragmentation and possibly missing/incompatible
              pieces. Today, the ObjectTalk ecosystem compiles into that single
              unit that contains everything. The file called “ot” can be moved
              around with easy and will always be complete, coherent and in
              sync.
            </p>
            <p>
              During the compilation of ObjectTalk it is decided whether some
              user interface subsystems are included. On headless Linux systems,
              the Graphical User Interface (GUI) is omitted and the “ot”
              executable can only run command line scripts or simple servers
              like a web server. When the GUI libraries are available on the
              host system, “ot” is compiled to offer all subsystems. On MacOS
              and Windows this is the default but even here a stripped-down
              version can be compiled by setting a flag during compilation.
            </p>
            <p>
              Github is used as the
              <a href="https://github.com/goossens/ObjectTalk"
                >source code repository</a
              >
              and on every commit, the latest versions of the “ot” executable
              are built for MacOS, Linux and Windows and can be downloaded.
              Stable versions will also be made available from the same Github
              repository. Documentation for ObjectTalk is also included in the
              repository and the
              <a href="https://goossens.github.io/ObjectTalk"
                >documentation website</a
              >
              is automatically updated on every commit (off course the developer
              has to ensure the documentation is inline with the software.
              Documentation still doesn’t write itself).
            </p>
          </div>
          <div id="software">
            <h1 class="pb-2">Software Architecture</h1>
            <p>
              The diagram below depicts the subsystems included in the
              ObjectTalk ecosystem. As mentioned above, the four boxes on the
              right are available on both ObjectTalk configurations whereas the
              five boxes on the left are only available when the host operating
              system offers GUI libraries.
            </p>
            <p>
              <img
                src="img/software-architecture.png#center"
                alt="Software Architecture"
              />
            </p>
            <p><strong>Operating System Foundation</strong></p>
            <p>
              ObjectTalk currently runs on MacOS, Linux and Windows. In general,
              the main development platform is MacOS and typically the latest
              version is used. For Linux, Ubuntu 24.04 is used and on Billy
              boxes, Windows 11. The Github continuous integration tasks also
              use the latest versions of these operating systems. For those that
              use other Linux distributions, it is likely that ObjectTalk will
              compile out-of-the-box, but this is not verified.
            </p>
            <p>
              The entire ObjectTalk ecosystem is written in C++17 which is the
              most recent version that is best supported on all platforms. Once
              C++20 finds better support, we will switch to it.
            </p>
            <p>
              To simplify the ObjectTalk code baseline, the C++ standard library
              is used to the maximum extend possible. Basic I/O function,
              filesystem access, containers and memory management are simply
              used as is. Compiler developers typically do a good job optimizing
              things on each platform.
            </p>
            <p>
              I know there are lot of people out there that believe they can do
              better than the standard library (and they might be right) but the
              time required to optimize on multiple platforms is not worth it.
              I’m old enough to have written operating systems in assembler and
              had to maintain C libraries for even the most simple memory
              management or data structures. These days, I gladly take free
              cross platform solutions and sacrifice a few CPU cycles (I have
              more of those than brain cells).
            </p>
            <p>
              To prove that I'm a hypocrite, the one exception to the rule is
              shared pointers. The version included in the standard library is
              thread safe and therefore slow. Given that ObjectTalk always runs
              in a single thread, a replacement shared pointer class is included
              that is not thread safe but makes ObjectTalk twice as fast. Off
              course I argue that I would have used the standard library if it
              only had included a fast non-thread safe smart pointer.
            </p>
            <p><strong>Language Engine</strong></p>
            <p>
              The language engine uses some simple components to implement
              ObjectTalk. A lexical scanner turns source code into tokens, the
              single-pass compiler translates these tokens to bytecode for a
              platform-independent imaginary CPU, an optimizer turns simple code
              sequences into super instructions and the stack-based virtual
              machine executes this bytecode.
            </p>
            <p>
              <img
                src="img/language-architecture.png#center"
                alt="Language Architecture"
              />
            </p>
            <p><strong>Core Classes</strong></p>
            <p>
              Given that ObjectTalk’s virtual machine only understands a stack
              of opaque objects, there members, member functions and basic
              branching, even the most fundamental operations like additions,
              string manipulation and I/O must be implemented in ObjectTalk
              classes. The core classes subsystem provides fundamental classes
              for primitives (booleans, integers, reals, strings and functions),
              collections (arrays, dictionaries and sets) as well as a set of
              operating system, filesystem and stream classes.
            </p>
            <p><strong>Network Framework</strong></p>
            <p>
              These classes provide asynchronous access to network functions.
              When implementing servers or I/O heavy applications, you typically
              have two options. Firstly, you can go multithreaded and use many
              threads and thread pools to handle I/O request. This approach
              however has proven not to be too scalable and most web servers
              today don’t use it or have complicated strategies to deal with
              performance and bottlenecks. The other approach is to use a single
              thread with an event loop that runs as fast as possible and simply
              responds to operating system events whenever they happen.
              ObjectTalk uses this last approach based on the
              <a href="http://docs.libuv.org/">Libuv</a> library that offers
              asynchronous operations as a cross-platform solutions. Libuv was
              originally developed for
              <a href="https://nodejs.org/">Node.js</a> and is still in use
              there. This means that it is well tested and maintained.
            </p>
            <p><strong>Network Classes</strong></p>
            <p>
              ObjectTalk provides a number of classes that make it easy to
              implement a web server on top of the network framework. For those
              familiar with <a href="https://nodejs.org/">Node.js</a> and the
              <a href="https://expressjs.com">Express package</a>, you will
              recognize the similarities. If you need an operational
              asynchronous web server, use
              <a href="https://nodejs.org/">Node.js</a>. If you want to use a
              simple server using a few lines of code, this ObjectTalk library
              might be the ticket.
            </p>
            <p><strong>Graphics Framework</strong></p>
            <p>
              As mentioned above, the graphics framework is optional and will
              only be compiled in when the host operating system provided the
              required GUI libraries. The foundation of this framework is
              provided by a number of open source cross-platform libraries.
              <a href="https://github.com/libsdl-org/SDL">SDL3</a>
              is used as an system independent abstraction for windows and
              user/system interactions.
              <a href="https://github.com/bkaradzic/bgfx">BGFX</a> is used as a
              system independent abstraction to render graphics supporting
              Metal, OpenGL, Vulkan and DirectX APIs.
              <a href="https://github.com/ocornut/imgui">Dear ImGui</a> is used
              as a neutral user interface library and all widgets are
              implemented with it. The framework glues all of this together and
              ObjectTalk users will never have to deal with this level of
              detail.
            </p>
            <p>
              In the original design for the graphics framework, the ObjectTalk
              language was used to construct all the components for a user
              interface. Unfortunately, this led to very verbose code and it
              would take pages of code to create all the things you would need
              for a user interface, 2D board or 3D scene. In fact, the ratio
              between construction code and functionality was so bad that a new
              approach was implemented.
            </p>
            <p>
              Today, the framework uses a variety of technics. A purely
              ObjectTalk driven approach is still available to implement simple
              GUIs or 2D games. For 3D scenes, an Entity Component System (ECS)
              as an architectural pattern to represent the elements of the
              scene. The IDE provides a visual editor for ECS data which is easy
              to use. To make 3D scenes scriptable, a basic ObjectTalk scripting
              component is available.
            </p>
            <p><strong>Graphics Classes</strong></p>
            <p>
              These classes provide scripting access to the graphics framework
              as well components to build GUIs. ObjectTalk has a rich set of
              platform independent widgets that can be used to create user
              interfaces and apps. In the included examples, the gui, arcade and
              pacman folders contain sample scripts to showcase the power of
              these classes.
            </p>
            <p><strong>Node Engine</strong></p>
            <p>
              Many years ago, I developed a graphical node-based editor to
              configure computer I/O systems complete with stream processing and
              protocol conversion. This worked really well and it allowed
              non-programmers to assist during development, maintenance and
              operations. Once I played with Blender's nodes for geometry and
              shaders, I thought it was a good idea to also add nodes to
              ObjectTalk. Please keep in mind though that becoming a Blender
              clone is not one of the ambitions of this project.
            </p>
            <p>
              Each node really feels like an object instance and drawing
              connections between them is akin to visual programming. Today, in
              ObjectTalk, the IDE has an node editor that allows you to setup
              nodes and connect them into a graph. These graphs are
              automatically reevaluated when values change. The examples folder
              contains image processing chains and nodes are used in the scene
              examples to process images or create geometry. ObjectTalk already
              has over 50 nodes already and many will follow depending on my
              needs.
            </p>
            <p><strong>3D Scenes</strong></p>
            <p>
              As mentioned above, 3D scenes are based on an Entity Component
              System (ECS) that allows you to define entities (objects in the
              real world) and associate a variety of components with them that
              offer functionality.
            </p>
            <p>
              The 3D scene ECS also has nodes and script components to make the
              whole thing more dynamic. In the examples folder, you'll find
              automatically spinning cubes based on timers and an earth rotating
              based on mouse movements. Both of these a driven by script
              components. The jungle and island examples use nodes to
              procedurally create terrain and asset instances.
            </p>
            <p>
              To round it all out, modern engine features like geometry/model
              importing, support for animated models, deferred rendering,
              Physically Based Rendering (PBR), particle systems, Image Based
              Lighting (IBL), Cascaded Shadow Maps (CSMs) and post processing
              with Fog, Bloom, God Rays, Fast Approximate Anti-Aliasing (FXAA),
              Exposure/Contrast correction and Tone Mapping are also available.
            </p>
            <p><strong>Integrated Development Environment (IDE)</strong></p>
            <p>
              To top it all off, ObjectTalk comes with its own IDE to edit
              ObjectTalk scripts, scenes and nodes. The IDE runs in a single
              window (with tabs) and has full undo/redo/cut/copy/paste
              capabilities for all content types. From the IDE, script, scenes
              and nodes can be validated and run. Errors are highlighted inline
              making it easy and fast to finish a project. It includes the
              following editors:
            </p>
            <ul>
              <li>
                <p><strong>ObjectTalk script editor</strong></p>
                <ul>
                  <li>
                    This editor provides a powerful syntax highlighting
                    capability modeled after a subset of Visual Studio Code.
                  </li>
                  <li>
                    The editor has full undo capabilities and works with UTF-8
                    encoded text.
                  </li>
                  <li>
                    The editor can launch ObjectTalk scripts and has a console
                    for output and highlighting for errors.
                  </li>
                  <li>A visual debugger is also available.</li>
                </ul>
              </li>
              <li>
                <p><strong>Node editor</strong></p>
                <ul>
                  <li>This editor allows the creation of node graphs.</li>
                  <li>The editor has full undo capabilities.</li>
                  <li>
                    The editor automatically evaluates graphs so it can be used
                    for realtime visual programming (e.g. image processing or
                    asset generation).
                  </li>
                </ul>
              </li>
              <li>
                <p><strong>Scene editor</strong></p>
                <ul>
                  <li>
                    This editor allows the creation and configuration of
                    entities and components.
                  </li>
                  <li>
                    Entities are stored in trees making it easy to create entity
                    hierarchies.
                  </li>
                  <li>The editor has full undo capabilities.</li>
                  <li>
                    Scenes can be run directly from the IDE to ensures node and
                    script components function properly.
                  </li>
                </ul>
              </li>
              <li>
                <p><strong>Miscellaneous editors</strong></p>
                <ul>
                  <li>
                    The IDE is also capable of editing pure text, JSON and
                    Markdown files (complete with syntax highlighting).
                  </li>
                </ul>
              </li>
            </ul>
          </div>
          <div id="runtime">
            <h1 class="pb-2">Runtime Architecture</h1>
            <p>
              As was explained above, the ObjectTalk ecosystem comes as a single
              executable file called “ot”. This single executable can run in
              four different modes depending on how it was launched.
            </p>
            <p><strong>Simple Mode</strong></p>
            <p><img src="img/simple-mode.png" alt="Simple Mode" /></p>
            <p>
              In its simplest form, “ot” is a scripting engine that can execute
              ObjectTalk scripts from the command line. In this mode, the main
              (and only) thread compiles and executes the code until the script
              ends.
            </p>
            <p><strong>Server Mode</strong></p>
            <p><img src="img/server-mode.png" alt="Server Mode" /></p>
            <p>
              In server mode, a script is started like described above in Simple
              Mode. The difference is that at some point a server script starts
              the event loop after which control passed to the engine. Only
              callbacks are made from that point forward similar to other
              asynchronous frameworks like Node.js. The startup script as well
              as the event loop are all executed from the main and only thread.
            </p>
            <p><strong>Graphics Mode</strong></p>
            <p><img src="img/graphics-mode.png" alt="Graphics Mode" /></p>
            <p>
              In graphics mode, the starting point can be a script or a JSON
              file that contains all the information detailing the structure and
              capabilities of a GUI, scene or node-based processing. The JSON
              file can refer to external assets such as images, sprites or
              models and can also refer to ObjectTalk scripts that act as
              controllers in the created graphical world.
            </p>
            <p>
              The required JSON file can be constructed by hand but this is not
              recommended. The provided IDE has dedicated editors for all the
              graphical Entity Component System (ECS) and node-based JSON files.
            </p>
            <p>
              In graphical mode a number of threads are used to run the
              application which might be slightly different based on host
              operating system. The main thread will be used as the windowing
              and rendering thread. This thread interacts with the native
              windows system and communicates with the GPU. it is also used to
              run the application, do most of the CPU work and run the event
              loop. The ObjectTalk callbacks will also run in this thread.
            </p>
            <p>
              Additional worker threads might be spawned to do things like asset
              loading or heavier computations.
            </p>
            <p><strong>Integrate Development Environment (IDE) Mode</strong></p>
            <p><img src="img/ide-mode.png" alt="IDE Mode" /></p>
            <p>
              In the Integrate Development Environment (IDE) mode is the IDE
              will act as the main application just like any other program in
              graphics mode. When the IDE runs a script or graphics application,
              a subprocess is spawned in the applicable mode. Bi-directional
              Inter Process Communication (IPC) is setup to allow the IDE to
              communicate with the ObjectTalk script, GUI, scene or node-based
              apps. This is how the visual debugger is implemented.
            </p>
          </div>
        </div>
      </div>
      <div class="row flex-shrink-0 py-1 manual-footer" id="copyright">
        <p class="mx-auto py-0 my-0 small">
          Copyright (c) 1993-2025 Johan A. Goossens. All rights reserved.
        </p>
      </div>
    </div>
    <script src="js/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/jquery.easing.min.js"></script>
    <script src="js/theme.js"></script>
  </body>
</html>
