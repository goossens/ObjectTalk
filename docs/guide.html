<!doctype html>
<html lang="en">
  <head>
    <title>ObjectTalk Guide</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="fonts/font-awesome.min.css" />
    <link rel="stylesheet" type="text/css" href="css/theme.css" />
  </head>
  <body id="page-top">
    <div
      class="container-fluid d-flex flex-column flex-grow-1 vh-100 overflow-hidden"
    >
      <nav
        class="navbar navbar-expand px-0 pt-1 pb-0 flex-shrink-0 manual-header"
      >
        <a class="navbar-brand" href="index.html"
          ><img src="img/icon.png" height="40" alt="" /><span class="ml-2"
            >Documentation</span
          ></a
        ><button
          class="navbar-toggler navbar-toggler-right"
          data-toggle="collapse"
          data-target="#navbarResponsive"
          type="button"
          data-toogle="collapse"
          aria-controls="navbarResponsive"
          aria-expanded="false"
          aria-label="Toggle navigation"
        >
          <i class="fa fa-bars"></i>
        </button>
        <div class="collapse navbar-collapse" id="navbarResponsive">
          <ul class="navbar-nav ml-auto">
            <li class="nav-item">
              <a class="nav-link page-scroll" href="installation.html"
                >Installation</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link page-scroll" href="tour.html">Tour</a>
            </li>
            <li class="nav-item">
              <a class="nav-link page-scroll" href="guide.html">Guide</a>
            </li>
            <li class="nav-item dropdown">
              <a
                class="nav-link dropdown-toggle"
                href="#"
                id="Reference"
                role="button"
                data-toggle="dropdown"
                aria-haspopup="true"
                aria-expanded="false"
                >Reference</a
              >
              <div class="dropdown-menu" aria-labelledby="Reference">
                <a class="nav-link page-scroll" href="language.html">Language</a
                ><a class="nav-link page-scroll" href="classes.html">Classes</a
                ><a class="nav-link page-scroll" href="architecture.html"
                  >Architecture</a
                >
              </div>
            </li>
          </ul>
        </div>
      </nav>
      <div class="row flex-grow-1 overflow-hidden vh-100">
        <div class="col-2 mh-100 overflow-auto py-2 manual-toc">
          <p><strong>ObjectTalk Guide</strong></p>
          <ul>
            <li><a class="page-scroll" href="#basics">The Basics</a></li>
            <li><a class="page-scroll" href="#collections">Collections</a></li>
            <li><a class="page-scroll" href="#operators">Operators</a></li>
            <li><a class="page-scroll" href="#flow">Control Flow</a></li>
            <li><a class="page-scroll" href="#scope">Scope</a></li>
            <li><a class="page-scroll" href="#modules">Modules</a></li>
            <li><a class="page-scroll" href="#classes">Classes</a></li>
            <li><a class="page-scroll" href="#functions">Functions</a></li>
          </ul>
        </div>
        <div class="col mh-100 overflow-auto py-2 manual-content">
          <div id="basics">
            <h1 class="pb-2">The Basics</h1>
            <p>
              ObjectTalk is an object-oriented scripting language that was
              developed from the ground up to be efficient and pure.
              Nonetheless, many parts of ObjectTalk will be familiar if you have
              experience with developing in C and derived languages.
            </p>
            <p>
              ObjectTalk provides its own versions of fundamental C types,
              including Boolean, Integer (for int), Real (for double), String
              for textual data and Function as first class primitives.
              ObjectTalk also provides powerful versions of the three primary
              collection types: Array, Dictionary and Set. In fact, in
              ObjectTalk everything is an object derived from a class and the
              word type is only used internally in the language's runtime.
              Primitives like Booleans, Integers, Reals, Strings and Functions
              are objects just like Arrays, Dicts, Sets and HTTP servers.
            </p>
            <p><strong>Variables</strong></p>
            <p>
              Variables associate a name (e.g. myVariable) with an object
              derived from a certain class (e.g. the number 10 or the string
              &quot;Hello&quot;). Variables in ObjectTalk must be declared to
              establish visibility in a certain scope. In the following example
              (let's assume this is at the top level of a module), the value 10
              will be assigned to variable myVariable in the module's scope.
            </p>
            <pre><code>var myVariable = 10;
print(myVariable); // this will print the number 10.
</code></pre>
            <p>
              In the following example, the variable is assigned to a class and
              therefore becomes a class member.
            </p>
            <pre><code>class myClass: Object {
	var myVariable = 10;
}

print(myClass.myVariable); // this will print the number 10.
</code></pre>
            <p>
              As you can see from the examples, variables do not have to be type
              declared as the assignment determines what type of object is
              stored in the variable.
            </p>
            <p><strong>Comments</strong></p>
            <p>
              In ObjectTalk, you can use comments to include non-executable text
              in your code or as a note or reminder to yourself. Comments are
              ignored by the ObjectTalk compiler when your code is compiled.
              ObjectTalk allows three types of comments: multiline C-style
              comments, single line C++ style comments and single line
              shell-style comments.
            </p>
            <p>
              Multiline C-style comments start with a forward-slash followed by
              an asterisk:
            </p>
            <pre><code>/* This is also a comment
   written over multiple lines. */
</code></pre>
            <p>
              Single-line C++ style comments begin with two forward-slashes:
            </p>
            <pre><code>// This is a comment.
</code></pre>
            <p>Single-line shell-style comments begin with a number sign:</p>
            <pre><code># This is a comment.
</code></pre>
            <p>
              A shell style comment allows ObjectTalk scripts to be made
              executable in UNIX type systems. The following first line
              (typically called a &quot;shebang&quot;) tells the UNIX shell to
              execute this script with the ObjectTalk interpreter.
            </p>
            <pre><code>#!/usr/bin/ot
</code></pre>
            <p><strong>Semicolons</strong></p>
            <p>
              Unlike some newer languages, ObjectTalk mandates the use of
              Semicolons at the end of statements that don't end with a block.
              This allows statements to be written over multiple lines (without
              the need for backslashes) and it avoids possible ambiguity. For
              example, earlier versions of ObjectTalk allowed:
            </p>
            <pre><code>a = 10
++b
</code></pre>
            <p>
              To most people, it is obvious that we want to assign the number 10
              to variable a and pre-increment variable b. The compiler however
              doesn't known the first statement ended after the number 10 and it
              will generate code for:
            </p>
            <pre><code>a = 10++;
b;
</code></pre>
            <p>
              To avoid this confusion, semicolons are mandatory at the end of
              statements that don't end with a block so the ObjectTalk script
              should have read:
            </p>
            <pre><code>a = 10;
++b;
</code></pre>
            <p><strong>Null</strong></p>
            <p>
              Null is a special value that indicates a valueless state. All
              instances of the Object class are null values. The default global
              scope defines the variable <strong>null</strong> as a convenience.
            </p>
            <pre><code>var nothing = null;
var alsoNothing = Object();
</code></pre>
            <p><strong>Booleans</strong></p>
            <p>
              <a href="classes.html#boolean">Booleans</a> in ObjectTalk can only
              hold two logical values: true and false. The default global scope
              defines the variables <strong>true</strong> and
              <strong>false</strong> as a convenience. A large number of
              language operators or member functions return Booleans as a
              result.
            </p>
            <pre><code>var bool1 = true;
var bool2 = false;
var bool3 = !bool2;
</code></pre>
            <p><strong>Integers</strong></p>
            <p>
              <a href="classes.html#integer">Integers</a> are signed whole
              numbers with no fractional component, such as 42, +1 and -23. On
              most systems, this number is implemented as a 64-bit number
              meaning that the extremes are -9,223,372,036,854,775,808 and
              9,223,372,036,854,775,807 (inclusive).
            </p>
            <p>Integer literals can be written as:</p>
            <ul>
              <li>A decimal number, with no prefix</li>
              <li>A binary number, with a 0b or 0B prefix</li>
              <li>An octal number, with a 0o or 0O prefix</li>
              <li>A hexadecimal number, with a 0x or 0X prefix</li>
            </ul>
            <p>
              All the following integer literals have a decimal value of 17:
            </p>
            <pre><code>var decimalInteger = 17;
var binaryInteger = 0b10001;       // 17 in binary notation
var octalInteger = 0o21;           // 17 in octal notation
var hexadecimalInteger = 0x11;     // 17 in hexadecimal notation
</code></pre>
            <p><strong>Reals</strong></p>
            <p>
              <a href="classes.html#real">Reals</a> are signed floating point
              numbers with a fractional component, such as 3.14159, 0.1, and
              -273.15. Reals are implemented using 8 bytes and have a range of
              1.7E +/- 308 (15 digits).
            </p>
            <p>
              Real literals can be written as a floating point number with or
              without an exponent:
            </p>
            <pre><code>var decimalDouble = 12.1875;
var exponentDouble = -1.21875e1;
</code></pre>
            <p>
              The default global language context predefines the variable
              <strong>pi</strong> (3.14...) and <strong>e</strong> (2.71...) as
              a convenience.
            </p>
            <p><strong>Strings</strong></p>
            <p>
              <a href="classes.html#string">Strings</a> are a series of
              characters, such as &quot;hello, world&quot; or
              &quot;albatross&quot;. ObjectTalk strings are instances of the
              String class. Strings are made up of unicode characters encoded in
              UTF-8. Given that UTF-8 uses variable length encoding, ObjectTalk
              does not measure or index strings in bytes but rather in codewords
              that represent a character whether it is 1,2, 3 or 4 bytes long.
            </p>
            <p>
              String literals are encoded using the same logic as JSON making it
              easy to exchange information with other languages or systems. A
              string literal is a sequence of characters surrounded by double
              quotation marks (&quot;).
            </p>
            <pre><code>var someString = &quot;Some string literal value&quot;;
var message = &quot;\tMost Europeans like the \u00C4.\n&quot;;
</code></pre>
            <p>Multiline strings can also be created:</p>
            <pre><code>var quotation = &quot;The White Rabbit put on his spectacles.
	'Where shall I begin, please your Majesty?' he asked.

	'Begin at the beginning,' the King said gravely,
	'and go on till you come to the end; then stop.'&quot;;
</code></pre>
            <p><strong>Functions</strong></p>
            <p>
              <a href="classes.html#function">Functions</a> are self-contained
              chunks of code that perform a specific task. You give a function a
              name that identifies what it does, and this name is used to “call”
              the function to perform its task when needed. See the
              <a class="page-scroll" href="#functions">Functions section</a>
              below for more details.
            </p>
            <pre><code>function test1(callback) {
	callback();
}

var test2 = function() {
	print(&quot;Hello, world!&quot;);
};

test1(test2);
</code></pre>
          </div>
          <div id="collections">
            <h1 class="pb-2">Collections</h1>
            <p>
              ObjectTalk provides three primary collection types, known as
              <a href="classes.html#array">Arrays</a>,
              <a href="classes.html#dict">Dictionaries</a> and
              <a href="classes.html#set">Sets</a>. Arrays are ordered
              collections of values. Dictionaries are unordered collections of
              key-value associations. Sets are unordered collections of unique
              values.
            </p>
            <h3>Arrays</h3>
            <p>
              An array stores values in an ordered list. The same value can
              appear in an array multiple times at different positions.
            </p>
            <p><strong>Creating an Array</strong></p>
            <p>
              You can create an array using a literal or the Array class
              constructor:
            </p>
            <pre><code>var array1 = [];
var array2 = [1, 2, 3.14, &quot;test&quot;];
var array3 = Array();
var array4 = Array(1, 2, 3.14, &quot;test&quot;);
</code></pre>
            <p><strong>Accessing and Modifying an Array</strong></p>
            <p>
              You access and modify an array through its member functions, or by
              using the index (<strong>[]</strong>) and addition
              (<strong>+</strong>) operators.
            </p>
            <pre><code>var array = [1, 2, 3.14, &quot;test&quot;];

array.append(&quot;name&quot;);
array.insert(3, &quot;insert&quot;);
array += 9;

var size = array.size();

var entry = array[2];
array[0] = 0;

array.erase(2);
array.eraseMultiple(1, 2);
array.clear();
</code></pre>
            <p>You can merge arrays:</p>
            <pre><code>var array1 = [1, 2, 3.14, &quot;test&quot;];
var array2 = [8, 9];

var array3 = array1.merge(array2);
// array3 is now [1, 2, 3.14, &quot;test&quot;, 8, 9]
</code></pre>
            <p>You can use an array as a stack:</p>
            <pre><code>var stack = Array();
stack.push(5);
var item = stack.pop();
</code></pre>
            <p><strong>Iterating over an Array</strong></p>
            <p>
              You can iterate over the entire set of values in an array with the
              <strong>for-in</strong> loop:
            </p>
            <pre><code>var array = [1, 2, 3.14, &quot;test&quot;];

for item in array {
	print(item);
}
</code></pre>
            <p><strong>Sorting an Array</strong></p>
            <p>
              You can sort an array using the <strong>sort</strong>,
              <strong>rsort</strong> and <strong>csort</strong> member
              functions. <strong>sort</strong> puts the array elements in
              ascending order, <strong>rsort</strong> is a reverse sort putting
              the elements in a decending order and <strong>csort</strong> is a
              custom sort that allows you to provide a function to determine the
              order.
            </p>
            <pre><code>var array = [1, 2, 3, 4];

array.rsort();
// array is now [4, 3, 2, 1]

array.sort();
// array is now [1, 2, 3, 4]

array.csort(function(a, b) {
	return a &gt; b;
});

// array is now [4, 3, 2, 1]
</code></pre>
            <h3>Dictionaries</h3>
            <p>
              A dictionary stores associations between string keys and values in
              a collection with no defined ordering. Each value is associated
              with a unique key, which acts as an identifier for that value
              within the dictionary. Unlike items in an array, items in a
              dictionary don’t have a specified order. You use a dictionary when
              you need to look up values based on their identifier, in much the
              same way that a real-world dictionary is used to look up the
              definition for a particular word.
            </p>
            <p><strong>Creating a Dictionary</strong></p>
            <p>
              You can create an Dictionary using a literal or the Dict class
              constructor:
            </p>
            <pre><code>var dict1 = { &quot;name&quot;: &quot;Doe&quot;, &quot;age&quot;: 29 };
var dict2 = Dict(&quot;name&quot;, &quot;Smith&quot;, &quot;age&quot;, 31);
</code></pre>
            <p><strong>Accessing and Modifying a Dictionary</strong></p>
            <p>
              You access and modify a dictionary through its member functions,
              or by using index operator (<strong>[]</strong>).
            </p>
            <pre><code>var dict = Dict();

dict[&quot;name&quot;] = &quot;John&quot;;
dict[&quot;age&quot;] = 39;
dict.erase(&quot;age&quot;);

var size = dict.size();

dict.clear();
</code></pre>
            <p><strong>Iterating over a Dictionary</strong></p>
            <p>You can iterate over a dictionary's keys or values.</p>
            <pre><code>var dict = { &quot;name&quot;: &quot;Doe&quot;, &quot;age&quot;: 29 };

for key in dict.keys() {
	print(key, &quot;: &quot;, dict[key]);
}

for value in dict.values() {
	print(value);
}
</code></pre>
            <p><strong>Dictionary Membership</strong></p>
            <p>
              Dictionary membership can be determined with the
              <strong>(not) in</strong> operators or the contains member
              functions.
            </p>
            <p>
              var dict = { &quot;name&quot;: &quot;Doe&quot;, &quot;age&quot;:
              29 };
            </p>
            <pre><code>assert(&quot;name&quot; in dict);
assert(&quot;address&quot; not in dict);
assert(dict.contains(&quot;age&quot;) == true);
</code></pre>
            <h3>Sets</h3>
            <p>
              A set stores distinct values in a collection with no defined
              ordering. You can use a set instead of an array when the order of
              items isn’t important, or when you need to ensure that an item
              only appears once.
            </p>
            <p><strong>Creating a Set</strong></p>
            <p>You can create a set with the Set class constructor.</p>
            <pre><code>var set1 = Set();
var set2 = Set(1, 5, 9);
</code></pre>
            <p><strong>Accessing and Modifying a Set</strong></p>
            <p>
              You access and modify a set through its member functions, or by
              using the addition (<strong>+</strong>) and subtraction
              (<strong>-</strong>) operators.
            </p>
            <pre><code>var set = Set();
set.insert(1);
set += 2;
set.insert(4);
s -= 1;
set.erase(2);

var size = set.size();

set.clear();
</code></pre>
            <p><strong>Set Operations</strong></p>
            <p>
              You can efficiently perform fundamental set operations, such as
              combining two sets together, determining which values two sets
              have in common, or determining whether two sets contain all, some,
              or none of the same values.
            </p>
            <pre><code>var set = Set(1, 2, 3, 5);
var set2 = Set(1, 3, 6, 8);

assert(set.intersection(set2) == Set(1, 3));
assert(set.difference(set2) == Set(2, 5, 6, 8));
assert(set.union(set2) == Set(1, 2, 3, 5, 6, 8));
assert(set.subtract(set2) == Set(2, 5));
</code></pre>
            <p><strong>Iterating over a Set</strong></p>
            <p>
              You can iterate over the entire set of values in an array with the
              <strong>for-in</strong> loop:
            </p>
            <pre><code>var set = Set(1, 2, 3.14, &quot;test&quot;);

for item in set {
	print(item);
}
</code></pre>
            <p><strong>Set Membership</strong></p>
            <p>
              Set membership can be determined with the
              <strong>(not) in</strong> operators or the
              <strong>contains</strong> member functions.
            </p>
            <pre><code>var set = Set(1, 2, 3.14, &quot;test&quot;);

assert(1 in set);
assert(&quot;hello&quot; not in set);
assert(set.contains(&quot;test&quot;) == true);
</code></pre>
          </div>
          <div id="operators">
            <h1 class="pb-2">Operators</h1>
            <p>
              An operator is a special symbol or phrase that you use to check,
              change, or combine values. For example, the addition operator
              (<strong>+</strong>) adds two objects, as in
              <strong>var i = 1 + 2</strong>, and the logical AND operator
              (<strong>&amp;&amp;</strong>) combines two Boolean values, as in
              <strong>if enteredDoorCode &amp;&amp; passedRetinaScan</strong>.
              ObjectTalk supports the operators you may already know from
              languages like C.
            </p>
            <p><strong>Terminology</strong></p>
            <p>Operators are unary, binary, or ternary:</p>
            <ul>
              <li>
                <strong>Unary operators</strong> operate on a single target
                (such as -a). Unary prefix operators appear immediately before
                their target (such as !b), and unary postfix operators appear
                immediately after their target (such as c++).
              </li>
              <li>
                <strong>Binary operators</strong> operate on two targets (such
                as 2 + 3) and are infix because they appear in between their two
                targets.
              </li>
              <li>
                <strong>Ternary operators</strong> operate on three targets.
                Like C, ObjectTalk has only one ternary operator, the ternary
                conditional operator (a ? b : c).
              </li>
            </ul>
            <p>
              The values that operators affect are operands. In the expression 1
              + 2, the + symbol is a binary operator and its two operands are
              the values 1 and 2.
            </p>
            <p><strong>Assignment Operator</strong></p>
            <p>
              The assignment operator <strong>(a = b)</strong> initializes or
              updates the value of a with the value of b:
            </p>
            <pre><code>var b = 10;
var a = 5;
a = b;
// a is now equal to 10
</code></pre>
            <p><strong>Arithmetic Operators</strong></p>
            <p>ObjectTalk supports the four standard arithmetic operators:</p>
            <ul>
              <li>Addition (+)</li>
              <li>Subtraction (-)</li>
              <li>Multiplication (*)</li>
              <li>Division (/)</li>
            </ul>
            <p>Examples:</p>
            <pre><code>1 + 2       // equals 3
5 - 3       // equals 2
2 * 3       // equals 6
10.0 / 2.5  // equals 4.0
</code></pre>
            <p>
              The addition operator is also supported for String concatenation
              or for any class that implements the __add__ member function.
            </p>
            <pre><code>&quot;hello, &quot; + &quot;world&quot;  // equals &quot;hello, world&quot;
</code></pre>
            <p><strong>Remainder Operator</strong></p>
            <p>
              The remainder operator <strong>(a % b)</strong> works out how many
              multiples of b will fit inside a and returns the value that’s left
              over (known as the remainder).
            </p>
            <p><strong>Unary Minus Operator</strong></p>
            <p>
              The sign of a numeric value can be toggled using a prefixed -,
              known as the unary minus operator:
            </p>
            <pre><code>var three = 3;
var minusThree = -three;       // equals -3
var plusThree = -minusThree;   // equals 3, or &quot;minus minus three&quot;
</code></pre>
            <p>
              The unary minus operator (-) is prepended directly before the
              value it operates on, without any white space.
            </p>
            <p><strong>Unary Plus Operator</strong></p>
            <p>
              The unary plus operator <strong>(+)</strong> simply returns the
              value it operates on, without any change:
            </p>
            <pre><code>let minusSix = -6;
let alsoMinusSix = +minusSix;  // equals -6
</code></pre>
            <p>
              Although the unary plus operator doesn’t actually do anything, you
              can use it to provide symmetry in your code for positive numbers
              when also using the unary minus operator for negative numbers.
            </p>
            <p><strong>Compound Assignment Operators</strong></p>
            <p>
              Like C, ObjectTalk provides compound assignment operators that
              combine assignment <strong>(=)</strong> with another operation.
              One example is the addition assignment operator
              <strong>(+=)</strong>:
            </p>
            <pre><code>var a = 1;
a += 2;
// a is now equal to 3
</code></pre>
            <p>
              The expression a += 2 is shorthand for a = a + 2. Effectively, the
              addition and the assignment are combined into one operator that
              performs both tasks at the same time. The generated code for a +=
              2 however is identical to the code generated for a = a + 2. a += 2
              is therefore just &quot;syntactical sugar&quot;.
            </p>
            <p><strong>Comparison Operators</strong></p>
            <p>ObjectTalk supports the following comparison operators:</p>
            <ul>
              <li>Equal to (a == b)</li>
              <li>Not equal to (a != b)</li>
              <li>Greater than (a &gt; b)</li>
              <li>Less than (a &lt; b)</li>
              <li>Greater than or equal to (a &gt;= b)</li>
              <li>Less than or equal to (a &lt;= b)</li>
            </ul>
            <p>Examples:</p>
            <pre><code>1 == 1   // true because 1 is equal to 1
2 != 1   // true because 2 isn't equal to 1
2 &gt; 1    // true because 2 is greater than 1
1 &lt; 2    // true because 1 is less than 2
1 &gt;= 1   // true because 1 is greater than or equal to 1
2 &lt;= 1   // false because 2 isn't less than or equal to 1
</code></pre>
            <p>
              Comparison operators are often used in conditional statements,
              such as the if statement:
            </p>
            <pre><code>var name = &quot;world&quot;;

if name == &quot;world&quot; {
    print(&quot;hello, world&quot;)

} else {
    print(&quot;I'm sorry &quot;, name, &quot;, but I don't recognize you&quot;)
}

// prints &quot;hello, world&quot;
</code></pre>
            <p><strong>Ternary Conditional Operator</strong></p>
            <p>
              The ternary conditional operator is a special operator with three
              parts, which takes the form question ? answer1 : answer2. It’s a
              shortcut for evaluating one of two expressions based on whether
              question is true or false. If question is true, it evaluates
              answer1 and returns its value; otherwise, it evaluates answer2 and
              returns its value. The ternary conditional operator is shorthand
              for the code below:
            </p>
            <pre><code>if question {
    answer1

} else {
    answer2
}
</code></pre>
            <p>
              Here’s an example, which calculates the height for a table row.
              The row height should be 50 points taller than the content height
              if the row has a header, and 20 points taller if the row doesn’t
              have a header:
            </p>
            <pre><code>var contentHeight = 40;
var hasHeader = true;
var rowHeight = contentHeight + (hasHeader ? 50 : 20);
// rowHeight is equal to 90
</code></pre>
            <p>The example above is shorthand for the code below:</p>
            <pre><code>var contentHeight = 40;
var hasHeader = true;
var rowHeight;

if hasHeader {
    rowHeight = contentHeight + 50;

} else {
    rowHeight = contentHeight + 20;
}

// rowHeight is equal to 90
</code></pre>
            <p>
              The first example’s use of the ternary conditional operator means
              that rowHeight can be set to the correct value on a single line of
              code, which is more concise than the code used in the second
              example.
            </p>
            <p>
              The ternary conditional operator provides an efficient shorthand
              for deciding which of two expressions to consider. Use the ternary
              conditional operator with care, however. Its conciseness can lead
              to hard-to-read code if overused. Avoid combining multiple
              instances of the ternary conditional operator into one compound
              statement.
            </p>
            <p><strong>Logical Operators</strong></p>
            <p>
              Logical operators modify or combine the Boolean logic values true
              and false. ObjectTalk supports the three standard logical
              operators found in C-based languages:
            </p>
            <ul>
              <li>Logical NOT (!a)</li>
              <li>Logical AND (a &amp;&amp; b)</li>
              <li>Logical OR (a || b)</li>
            </ul>
            <p>
              Please note that the logical AND and OR operators use
              short-circuit evaluation meaning that of the left side of AND
              eveluates to false or the left side of OR eveluates to true, the
              right side is not evaluated as the result is already known. You
              can read more about this on
              <a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation"
                >Wikipedia</a
              >.
            </p>
            <p><strong>Logical NOT Operator</strong></p>
            <p>
              The logical NOT operator <strong>(!a)</strong> inverts a Boolean
              value so that true becomes false, and false becomes true.
            </p>
            <p>
              The logical NOT operator is a prefix operator, and appears
              immediately before the value it operates on, without any white
              space. It can be read as “not a”, as seen in the following
              example:
            </p>
            <pre><code>var allowedEntry = false;

if !allowedEntry {
    print(&quot;ACCESS DENIED&quot;);
}

// Prints &quot;ACCESS DENIED&quot;
</code></pre>
            <p>
              The phrase if !allowedEntry can be read as “if not allowed entry.”
              The subsequent line is only executed if “not allowed entry” is
              true; that is, if allowedEntry is false.
            </p>
            <p>
              As in this example, careful choice of Boolean constant and
              variable names can help to keep code readable and concise, while
              avoiding double negatives or confusing logic statements.
            </p>
            <p><strong>Logical AND Operator</strong></p>
            <p>
              The logical AND operator <strong>(a &amp;&amp; b)</strong> creates
              logical expressions where both values must be true for the overall
              expression to also be true.
            </p>
            <p>
              If either value is false, the overall expression will also be
              false. In fact, if the first value is false, the second value
              won’t even be evaluated, because it can’t possibly make the
              overall expression equate to true. This is known as short-circuit
              evaluation.
            </p>
            <p>
              This example considers two Bool values and only allows access if
              both values are true:
            </p>
            <pre><code>var enteredDoorCode = true;
var passedRetinaScan = false;

if enteredDoorCode &amp;&amp; passedRetinaScan {
    print(&quot;Welcome!&quot;);

} else {
    print(&quot;ACCESS DENIED&quot;);
}

// Prints &quot;ACCESS DENIED&quot;
</code></pre>
            <p><strong>Logical OR Operator</strong></p>
            <p>
              The logical OR operator <strong>(a || b)</strong> is an infix
              operator made from two adjacent pipe characters. You use it to
              create logical expressions in which only one of the two values has
              to be true for the overall expression to be true.
            </p>
            <p>
              Like the Logical AND operator above, the Logical OR operator uses
              short circuit evaluation to consider its expressions. If the left
              side of a Logical OR expression is true, the right side isn’t
              evaluated, because it can’t change the outcome of the overall
              expression.
            </p>
            <p>
              In the example below, the first Bool value (hasDoorKey) is false,
              but the second value (knowsOverridePassword) is true. Because one
              value is true, the overall expression also evaluates to true, and
              access is allowed:
            </p>
            <pre><code>var hasDoorKey = false;
var knowsOverridePassword = true;

if hasDoorKey || knowsOverridePassword {
    print(&quot;Welcome!&quot;);

} else {
    print(&quot;ACCESS DENIED&quot;);
}

// Prints &quot;Welcome!&quot;
</code></pre>
            <p><strong>Combining Logical Operators</strong></p>
            <p>
              You can combine multiple logical operators to create longer
              compound expressions:
            </p>
            <pre><code>if enteredDoorCode &amp;&amp; passedRetinaScan || hasDoorKey || knowsOverridePassword {
    print(&quot;Welcome!&quot;);

} else {
    print(&quot;ACCESS DENIED&quot;);
}

// Prints &quot;Welcome!&quot;
</code></pre>
            <p>
              This example uses multiple &amp;&amp; and || operators to create a
              longer compound expression. However, the &amp;&amp; and ||
              operators still operate on only two values, so this is actually
              three smaller expressions chained together. The example above is
              evaluated from left to right but it would probably make sense to
              use parenthesis for readability (see below).
            </p>
            <p>
              If we’ve entered the correct door code and passed the retina scan,
              or if we have a valid door key, or if we know the emergency
              override password, then allow access.
            </p>
            <p>
              Based on the values of enteredDoorCode, passedRetinaScan, and
              hasDoorKey, the first two subexpressions are false. However, the
              emergency override password is known, so the overall compound
              expression still evaluates to true.
            </p>
            <p><strong>Explicit Parentheses</strong></p>
            <p>
              It’s sometimes useful to include parentheses when they’re not
              strictly needed, to make the intention of a complex expression
              easier to read. In the door access example above, it’s useful to
              add parentheses around the first part of the compound expression
              to make its intent explicit:
            </p>
            <pre><code>if (enteredDoorCode &amp;&amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword {
    print(&quot;Welcome!&quot;);

} else {
    print(&quot;ACCESS DENIED&quot;);
}

// Prints &quot;Welcome!&quot;
</code></pre>
            <p>
              The parentheses make it clear that the first two values are
              considered as part of a separate possible state in the overall
              logic. The output of the compound expression doesn’t change, but
              the overall intention is clearer to the reader. Readability is
              always preferred over brevity; use parentheses where they help to
              make your intentions clear.
            </p>
            <p><strong>Operator Overview and Priorities</strong></p>
            <p>
              The table below list all the operators used in ObjectTalk
              including their priority and member function name.
            </p>
            <table class="table table-striped">
              <thead>
                <tr>
                  <th>Operator</th>
                  <th>Description</th>
                  <th>Priority</th>
                  <th>Member Function</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>[]</td>
                  <td>Index</td>
                  <td>1</td>
                  <td>__index__</td>
                </tr>
                <tr>
                  <td>()</td>
                  <td>Call</td>
                  <td>1</td>
                  <td>__call__</td>
                </tr>
                <tr>
                  <td>.</td>
                  <td>Member</td>
                  <td>1</td>
                  <td>__member__</td>
                </tr>
                <tr>
                  <td>++</td>
                  <td>Post-increment</td>
                  <td>1</td>
                  <td>__inc__</td>
                </tr>
                <tr>
                  <td>--</td>
                  <td>Post-decrement</td>
                  <td>1</td>
                  <td>__dec__</td>
                </tr>
                <tr>
                  <td>-</td>
                  <td>Unary minus</td>
                  <td>2</td>
                  <td>__neg__</td>
                </tr>
                <tr>
                  <td>+</td>
                  <td>Unary plus</td>
                  <td>2</td>
                  <td>__plus__</td>
                </tr>
                <tr>
                  <td>!</td>
                  <td>Logical NOT</td>
                  <td>2</td>
                  <td>__not__</td>
                </tr>
                <tr>
                  <td>~</td>
                  <td>Bitwise NOT</td>
                  <td>2</td>
                  <td>__bnot__</td>
                </tr>
                <tr>
                  <td>++</td>
                  <td>Pre-increment</td>
                  <td>2</td>
                  <td>__inc__</td>
                </tr>
                <tr>
                  <td>--</td>
                  <td>Pre-decrement</td>
                  <td>2</td>
                  <td>__dec__</td>
                </tr>
                <tr>
                  <td>*</td>
                  <td>Multiply</td>
                  <td>3</td>
                  <td>__mul__</td>
                </tr>
                <tr>
                  <td>/</td>
                  <td>Divide</td>
                  <td>3</td>
                  <td>__div__</td>
                </tr>
                <tr>
                  <td>**</td>
                  <td>Power</td>
                  <td>3</td>
                  <td>__power__</td>
                </tr>
                <tr>
                  <td>%</td>
                  <td>Remainder</td>
                  <td>3</td>
                  <td>__mod__</td>
                </tr>
                <tr>
                  <td>+</td>
                  <td>Add</td>
                  <td>4</td>
                  <td>__add__</td>
                </tr>
                <tr>
                  <td>-</td>
                  <td>Subtract</td>
                  <td>4</td>
                  <td>__sub__</td>
                </tr>
                <tr>
                  <td>&lt;&lt;</td>
                  <td>Bitwise left shift</td>
                  <td>5</td>
                  <td>__lshift__</td>
                </tr>
                <tr>
                  <td>&gt;&gt;</td>
                  <td>Bitwise right shift</td>
                  <td>5</td>
                  <td>__rshift__</td>
                </tr>
                <tr>
                  <td>&lt;</td>
                  <td>Less than</td>
                  <td>6</td>
                  <td>__lt__</td>
                </tr>
                <tr>
                  <td>&lt;=</td>
                  <td>Less than or equal</td>
                  <td>6</td>
                  <td>__le__</td>
                </tr>
                <tr>
                  <td>&gt;</td>
                  <td>Greater than</td>
                  <td>6</td>
                  <td>__gt__</td>
                </tr>
                <tr>
                  <td>&gt;=</td>
                  <td>Greater than or equal</td>
                  <td>6</td>
                  <td>__ge__</td>
                </tr>
                <tr>
                  <td>in</td>
                  <td>is in</td>
                  <td>6</td>
                  <td>__contains__</td>
                </tr>
                <tr>
                  <td>not in</td>
                  <td>is not in</td>
                  <td>6</td>
                  <td></td>
                </tr>
                <tr>
                  <td>==</td>
                  <td>Equal</td>
                  <td>7</td>
                  <td>__eq__</td>
                </tr>
                <tr>
                  <td>!=</td>
                  <td>Not equal</td>
                  <td>7</td>
                  <td>__ne__</td>
                </tr>
                <tr>
                  <td>&amp;</td>
                  <td>Bitwise AND</td>
                  <td>8</td>
                  <td>__band__</td>
                </tr>
                <tr>
                  <td>^</td>
                  <td>Bitwise XOR</td>
                  <td>9</td>
                  <td>__bxor__</td>
                </tr>
                <tr>
                  <td>|</td>
                  <td>Bitwise OR</td>
                  <td>10</td>
                  <td>__bor__</td>
                </tr>
                <tr>
                  <td>&amp;&amp;</td>
                  <td>Logical AND</td>
                  <td>11</td>
                  <td>__and__</td>
                </tr>
                <tr>
                  <td>||</td>
                  <td>Logical OR</td>
                  <td>12</td>
                  <td>__or__</td>
                </tr>
                <tr>
                  <td>?:</td>
                  <td>Ternary conditional</td>
                  <td>13</td>
                  <td></td>
                </tr>
                <tr>
                  <td>=</td>
                  <td>Assign</td>
                  <td>14</td>
                  <td>__assign__</td>
                </tr>
                <tr>
                  <td>*=</td>
                  <td>Multiply and assign</td>
                  <td>14</td>
                  <td></td>
                </tr>
                <tr>
                  <td>/=</td>
                  <td>Divide and assign</td>
                  <td>14</td>
                  <td></td>
                </tr>
                <tr>
                  <td>%=</td>
                  <td>Remainder and assign</td>
                  <td>14</td>
                  <td></td>
                </tr>
                <tr>
                  <td>+=</td>
                  <td>Add and assign</td>
                  <td>14</td>
                  <td></td>
                </tr>
                <tr>
                  <td>-=</td>
                  <td>Subtract and assign</td>
                  <td>14</td>
                  <td></td>
                </tr>
                <tr>
                  <td>&lt;&lt;=</td>
                  <td>Left bit shift and assign</td>
                  <td>14</td>
                  <td></td>
                </tr>
                <tr>
                  <td>&gt;&gt;=</td>
                  <td>Right bit shift and assign</td>
                  <td>14</td>
                  <td></td>
                </tr>
                <tr>
                  <td>&amp;=</td>
                  <td>Bitwise AND and assign</td>
                  <td>14</td>
                  <td></td>
                </tr>
                <tr>
                  <td>|=</td>
                  <td>Bitwise OR and assign</td>
                  <td>14</td>
                  <td></td>
                </tr>
                <tr>
                  <td>^=</td>
                  <td>Bitwise XOR and assign</td>
                  <td>14</td>
                  <td></td>
                </tr>
              </tbody>
            </table>
          </div>
          <div id="flow">
            <h1 class="pb-2">Control Flow</h1>
            <p>
              ObjectTalk provides a variety of control flow statements. These
              include while loops to perform a task multiple times; if
              statements to execute different branches of code based on certain
              conditions. ObjectTalk also provides a for-in loop that makes it
              easy to iterate over arrays, dictionaries, sets, strings, and
              other sequences.
            </p>
            <p><strong>If</strong></p>
            <p>
              In its simplest form, the <strong>if</strong> statement has a
              single condition. It executes a set of statements only if that
              condition is true.
            </p>
            <pre><code>var temperatureInFahrenheit = 30;

if temperatureInFahrenheit &lt;= 32 {
	print(&quot;It's very cold. Consider wearing a scarf.&quot;);
}

// Prints &quot;It's very cold. Consider wearing a scarf.&quot;
</code></pre>
            <p>
              The example above checks whether the temperature is less than or
              equal to 32 degrees Fahrenheit (the freezing point of water). If
              it is, a message is printed. Otherwise, no message is printed, and
              code execution continues after the if statement’s closing brace.
            </p>
            <p>
              The <strong>if</strong> statement can provide an alternative set
              of statements, known as an <strong>else</strong> clause, for
              situations when the if condition is false. These statements are
              indicated by the else keyword.
            </p>
            <pre><code>var temperatureInFahrenheit = 40;

if temperatureInFahrenheit &lt;= 32 {
	print(&quot;It's very cold. Consider wearing a scarf.&quot;);

} else {
	print(&quot;It's not that cold. Wear a t-shirt.&quot;);
}

// Prints &quot;It's not that cold. Wear a t-shirt.&quot;
</code></pre>
            <p>
              One of these two branches is always executed. Because the
              temperature has increased to 40 degrees Fahrenheit, it’s no longer
              cold enough to advise wearing a scarf and so the else branch is
              triggered instead.
            </p>
            <p>
              You can chain multiple if statements together to consider
              additional clauses by using the <strong>elif</strong> statement.
            </p>
            <pre><code>var temperatureInFahrenheit = 90;

if temperatureInFahrenheit &lt;= 32 {
	print(&quot;It's very cold. Consider wearing a scarf.&quot;);

} elif temperatureInFahrenheit &gt;= 86 {
	print(&quot;It's really warm. Don't forget to wear sunscreen.&quot;);

} else {
	print(&quot;It's not that cold. Wear a t-shirt.&quot;);
}

// Prints &quot;It's really warm. Don't forget to wear sunscreen.&quot;
</code></pre>
            <p>
              Here, an additional <strong>elif</strong> statement was added to
              respond to particularly warm temperatures. The final else clause
              remains, and it prints a response for any temperatures that are
              neither too warm nor too cold.
            </p>
            <p>
              The final else clause is optional, however, and can be excluded if
              the set of conditions doesn’t need to be complete.
            </p>
            <pre><code>var temperatureInFahrenheit = 72;

if temperatureInFahrenheit &lt;= 32 {
	print(&quot;It's very cold. Consider wearing a scarf.&quot;);

} elif temperatureInFahrenheit &gt;= 86 {
	print(&quot;It's really warm. Don't forget to wear sunscreen.&quot;);
}
</code></pre>
            <p>
              Because the temperature is neither too cold nor too warm to
              trigger the if or else if conditions, no message is printed.
            </p>
            <p><strong>While Loops</strong></p>
            <p>
              A while loop performs a set of statements until a condition
              becomes false. These kinds of loops are best used when the number
              of iterations isn’t known before the first iteration begins.
              ObjectTalk provides two kinds of while loops:
            </p>
            <ul>
              <li>
                <strong>while</strong> evaluates its condition at the start of
                each pass through the loop.
              </li>
              <li>
                <strong>do-while</strong> evaluates its condition at the end of
                each pass through the loop.
              </li>
            </ul>
            <p><strong>While</strong></p>
            <p>
              A while loop starts by evaluating a single condition. If the
              condition is true, a set of statements is repeated until the
              condition becomes false.
            </p>
            <p>Here’s the general form of a while loop:</p>
            <pre><code>while condition {
	statements
}
</code></pre>
            <p>
              This example plays a simple game of Snakes and Ladders (also known
              as Chutes and Ladders):
            </p>
            <p>The rules of the game are as follows:</p>
            <ul>
              <li>
                The board has 25 squares, and the aim is to land on or beyond
                square 25.
              </li>
              <li>
                The player’s starting square is “square zero”, which is just off
                the bottom-left corner of the board.
              </li>
              <li>
                Each turn, you roll a six-sided dice and move by that number of
                squares, following the horizontal path indicated by the dotted
                arrow above.
              </li>
              <li>
                If your turn ends at the bottom of a ladder, you move up that
                ladder.
              </li>
              <li>
                If your turn ends at the head of a snake, you move down that
                snake.
              </li>
            </ul>
            <p>
              The game board is represented by an array of integers. Its size is
              based on a constant called finalSquare, which is used to
              initialize the array and also to check for a win condition later
              in the example. Because the players start off the board, on
              “square zero”, the board is initialized with 26 zero Int values,
              not 25.
            </p>
            <pre><code>var finalSquare = 25;

var board = Array();
board.fill(finalSquare + 1, 0);
</code></pre>
            <p>
              Some squares are then set to have more specific values for the
              snakes and ladders. Squares with a ladder base have a positive
              number to move you up the board, whereas squares with a snake head
              have a negative number to move you back down the board.
            </p>
            <pre><code>board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02;
board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08;
</code></pre>
            <p>
              Square 3 contains the bottom of a ladder that moves you up to
              square 11. To represent this, board[03] is equal to +08, which is
              equivalent to an integer value of 8 (the difference between 3 and
              11). To align the values and statements, the unary plus operator
              (+i) is explicitly used with the unary minus operator (-i) and
              numbers lower than 10 are padded with zeros.
            </p>
            <pre><code>var square = 0;
var diceRoll = 0;

while square &lt; finalSquare {
	// roll the dice
	diceRoll += 1;

	if diceRoll == 7 {
		diceRoll = 1;
	}

	// move by the rolled amount
	square += diceRoll;

	// if we're on the board, move up or down for a snake or ladder
	if square &lt; board.count {
		square += board[square];
	}
}

print(&quot;Game over!&quot;);
</code></pre>
            <p>
              The example above uses a very simple approach to dice rolling.
              Instead of generating a random number, it starts with a diceRoll
              value of 0. Each time through the while loop, diceRoll is
              incremented by one and is then checked to see whether it has
              become too large. Whenever this return value equals 7, the dice
              roll has become too large and is reset to a value of 1. The result
              is a sequence of diceRoll values that’s always 1, 2, 3, 4, 5, 6,
              1, 2 and so on.
            </p>
            <p>
              After rolling the dice, the player moves forward by diceRoll
              squares. It’s possible that the dice roll may have moved the
              player beyond square 25, in which case the game is over. To cope
              with this scenario, the code checks that square is less than the
              board array’s count property. If square is valid, the value stored
              in board[square] is added to the current square value to move the
              player up or down any ladders or snakes.
            </p>
            <p>
              The current while loop execution then ends, and the loop’s
              condition is checked to see if the loop should be executed again.
              If the player has moved on or beyond square number 25, the loop’s
              condition evaluates to false and the game ends.
            </p>
            <p>
              A while loop is appropriate in this case, because the length of
              the game isn’t clear at the start of the while loop. Instead, the
              loop is executed until a particular condition is satisfied.
            </p>
            <p><strong>Do-While</strong></p>
            <p>
              The other variation of the while loop, known as the
              <strong>do-while</strong> loop, performs a single pass through the
              loop block first, before considering the loop’s condition. It then
              continues to repeat the loop until the condition is false.
            </p>
            <p>Here’s the general form of a do-while loop:</p>
            <pre><code>do {
	statements
} while condition;
</code></pre>
            <p>
              Here’s the Snakes and Ladders example again, written as a do-while
              loop rather than a while loop. The values of finalSquare, board,
              square, and diceRoll are initialized in exactly the same way as
              with a while loop.
            </p>
            <pre><code>var finalSquare = 25;

var board = Array();
board.fill(finalSquare + 1, 0);

board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02;
board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08;

var square = 0;
var diceRoll = 0;
</code></pre>
            <p>
              In this version of the game, the first action in the loop is to
              check for a ladder or a snake. No ladder on the board takes the
              player straight to square 25, and so it isn’t possible to win the
              game by moving up a ladder. Therefore, it’s safe to check for a
              snake or a ladder as the first action in the loop.
            </p>
            <p>
              At the start of the game, the player is on “square zero”. board[0]
              always equals 0 and has no effect.
            </p>
            <pre><code>do {
	// move up or down for a snake or ladder
	square += board[square];

	// roll the dice
	diceRoll += 1;

	if diceRoll == 7 {
		diceRoll = 1;
	}

	// move by the rolled amount
	square += diceRoll;
} while square &lt; finalSquare;

print(&quot;Game over!&quot;);
</code></pre>
            <p>
              After the code checks for snakes and ladders, the dice is rolled
              and the player is moved forward by diceRoll squares. The current
              loop execution then ends.
            </p>
            <p>
              The loop’s condition (while square &lt; finalSquare) is the same
              as before, but this time it’s not evaluated until the end of the
              first run through the loop. The structure of the do-while loop is
              better suited to this game than the while loop in the previous
              example. In the do-while loop above, square += board[square] is
              always executed immediately after the loop’s while condition
              confirms that square is still on the board. This behavior removes
              the need for the array bounds check seen in the while loop version
              of the game described earlier.
            </p>
            <p><strong>For-In Loops</strong></p>
            <p>
              You use the <strong>for-in</strong> loop to iterate over a
              sequence, such as items in an array, dictionary, set or characters
              in a string.
            </p>
            <p>
              This example uses a for-in loop to iterate over the items in an
              array:
            </p>
            <pre><code>var names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;];

for name in names {
	print(&quot;Hello, &quot;, name, &quot;!&quot;);
}

// Hello, Anna!
// Hello, Alex!
// Hello, Brian!
// Hello, Jack!
</code></pre>
            <p>
              To use a preset range, you can use the
              <strong>range</strong> generator:
            </p>
            <pre><code>for number in range(4) {
	print(number);
}

// prints 0 1 2 3

for number in range(2, 6) {
	print(number);
}

// prints 2 3 4 5 6

for number in range(5, 9, 2) {
	print(number);
}

// prints 5 7 9

for number in range(10, 6, -2) {
	print(number);
}

// prints 10 8 6
</code></pre>
          </div>
          <div id="scope">
            <h1 class="pb-2">Scope</h1>
            <p>
              Scope is a concept that refers to where objects including
              functions and classes can be seen and accessed. In ObjectTalk,
              variables are declared and stored in a scope. The scope of a
              variable describes where in a program's text the variable may be
              used, while the extent or lifetime describes when in a program's
              execution a variable has a value.
            </p>
            <p>
              ObjectTalk uses lexical scoping (a detailed explanation can be
              found on
              <a href="https://en.wikipedia.org/wiki/Scope_(computer_science)"
                >Wikipedia</a
              >. In lexical scoping, name resolution depends on the location in
              the source code and the lexical context, which is defined by where
              the named object is defined.
            </p>
            <p>ObjectTalk implements 5 different scope types:</p>
            <ul>
              <li>
                <strong>Global Scope</strong> - When the ObjectTalk interpreter
                is started, a default global scope is created. This is the root
                scope and contains a small set of useful variables (null, true,
                false), a few high level functions (import, print, and assert)
                and the list of classes that can be instantiated by the user.
                For a detailed description see the documentation on the
                <a href="classes.html#global">Global class</a>. Global scope
                members are stored on the heap.
              </li>
              <li>
                <strong>Module Scope</strong> - An ObjectTalk
                <a class="page-scroll" href="#modules">module</a> is derived
                from a single source code file. Any object defined at the
                module's root level is added to the module's scope. The effect
                this achieves is that those objects have global visibility in
                that module and can simply be addressed by their name. If a
                module is imported into another module, the variables of the
                imported module can be accessed by the importer using the member
                notation (dot operator). Module scope members are stored on the
                heap.
              </li>
              <li>
                <strong>Class Scope</strong> - In ObjectTalk, classes represent
                a separate scope. Any object (variables, functions, subclasses)
                defined in a class become part of the class scope. These object
                can be addressed inside the class by their name and using the
                member notation (dot operator) outside of the class. Class scope
                members are stored on the heap.
              </li>
              <li>
                <strong>Function Scope</strong> - In ObjectTalk, functions
                represent a separate scope. Unlike the previous 3 types,
                function scope objects live on the stack as their lifetime tends
                to be short. The function scope includes the calling parameters.
              </li>
              <li>
                <strong>Block Scope</strong> - In ObjectTalk, every block (code
                contained in curly brackets({})). has it's own scope. Variables
                contained in blocks are stored on the stack as the are also very
                short lived.
              </li>
            </ul>
            <p>
              ObjectTalk does have a mechanism to capture variables from a
              parent scope using a closure mechanism. The special mechanism
              which is often required in lambda function or just because
              functions are first class citizens in ObjectTalk, is described in
              in the
              <a class="page-scroll" href="#closures">closure</a> section.
            </p>
          </div>
          <div id="modules">
            <h1 class="pb-2">Modules</h1>
            <p>
              A module is a single unit of code that’s built and shipped as a
              single unit and that can be imported by another module with
              ObjectTalk's import function.
            </p>
            <p>
              A source file is a single ObjectTalk module (in effect, a single
              file within an app). Although it’s common to define individual
              types in separate source files, a single source file can contain
              definitions for multiple classes, functions, and so on.
            </p>
            <p>
              When the ObjectTalk interpreter is started, it will load the
              specified script (source code) as the first module. Additional
              modules can be loaded with the import function. Here is an example
              based on two files; one containing a class definition and the
              other containing the main program.
            </p>
            <pre><code>// Module &quot;counter.ot&quot;

class Counter : Object {
	function__init__(this) {
		this.count = 0;
	}

	function increment(this) {
		this.count += 1;
	}
	function increment(this, amount) {
		this.count += amount;
	}
	function reset(this) {
		this.count = 0;
	}
}

// Module &quot;app.ot&quot;

var counter = import(&quot;counter&quot;);

var tracker = counter.Counter(); // the initial counter value is 0
assert(tracker.count == 0);

tracker.increment();             // the counter's value is now 1
assert(tracker.count == 1);

tracker.increment(5);            // the counter's value is now 6
assert(tracker.count == 6);

tracker.reset();                 // the counter's value is now 0
assert(tracker.count == 0);
</code></pre>
          </div>
          <div id="classes">
            <h1 class="pb-2">Classes</h1>
            <p>
              Classes are general-purpose, flexible constructs that become the
              building blocks of your program’s code. You define properties and
              member functions to add functionality to your classes using the
              same syntax you use to define variables and functions.
            </p>
            <p>
              An instance of a class is traditionally known as an object.
              However, in this ObjectTalk documentation the terms object and
              instance are used interchangeably.
            </p>
            <p><strong>Definition Syntax</strong></p>
            <p>
              You introduce classes with the <strong>class</strong> keyword:
            </p>
            <pre><code>class Resolution : Object {
	var width = 0;
	var height = 0;
}
</code></pre>
            <p>
              The example above defines a new class called Resolution (that is
              derived from the Object class), to describe a pixel-based display
              resolution. This class has two class variables called width and
              height. Class variables are variables that are stored as part of
              the class. All instances of Resolution share these variables. To
              have unique variables per instances we need to assign values to
              the instance member.
            </p>
            <pre><code>class Resolution : Object {
	// instance member initialized in constructor
	function__init__(this, width, height) {
		this.width = 0;
		this.height = 0;
	}
}

class VideoMode : Object {
	var classVariable = &quot;mode class&quot;;

	function__init__(this) {
		this.resolution = Resolution(1920, 1080);
		this.interlaced = false;
		this.frameRate = 0.0;
		this.name = null;
	}
}

var mode = VideoMode();
mode.name = &quot;Test Mode&quot;; // assign value to instance variable
</code></pre>
            <p>
              The example above also defines a new class called VideoMode, to
              describe a specific video mode for video display. This class has
              four instance variables. The first, resolution, is initialized
              with a new Resolution instance, which infers a property type of
              Resolution. For the other three properties, new VideoMode
              instances will be initialized with an interlaced setting of false
              (meaning “noninterlaced video”), a playback frame rate of 0.0, and
              an optional String value called name.
            </p>
            <p><strong>Class Instances</strong></p>
            <p>
              The Resolution and the VideoMode classes definition only describe
              what a Resolution or VideoMode will look like. They themselves
              don’t describe a specific resolution or video mode. To do that,
              you need to create an instance of the structure or class.
            </p>
            <pre><code>var someResolution = Resolution(1920, 1080);
var someVideoMode = VideoMode();
</code></pre>
            <p>
              The simplest form of initializer syntax uses the type name of the
              class followed by empty parentheses, such as VideoMode(). This
              creates a new instance of the class. In some cases (like the
              Resolution class above), the class constructor (__init__) can take
              additional parameters to initialize a class instance.
            </p>
            <p><strong>Accessing Members</strong></p>
            <p>
              You can access the members of an instance using dot syntax. In dot
              syntax, you write the property name immediately after the instance
              name, separated by a dot (.):
            </p>
            <pre><code>print(&quot;The width of someResolution is &quot;, someResolution.width);
// Prints &quot;The width of someResolution is 1920&quot;
</code></pre>
            <p>
              In this example, someResolution.width refers to the width property
              of someResolution, and returns its default initial value of 0.
            </p>
            <p>
              You can drill down into sub-properties, such as the width property
              in the resolution property of a VideoMode:
            </p>
            <pre><code>print(&quot;The width of someVideoMode is &quot;, someVideoMode.resolution.width&quot;);
// Prints &quot;The width of someVideoMode is 1920&quot;
</code></pre>
            <p>
              You can also use dot syntax to assign a new value to a variable
              property:
            </p>
            <pre><code>someVideoMode.resolution.width = 1280;
print(&quot;The width of someVideoMode is &quot;, someVideoMode.resolution.width&quot;);
// Prints &quot;The width of someVideoMode is 1280&quot;
</code></pre>
            <p>
              The dot notations can be used to access both instance and class
              member variables. When reading a member, the runtime will first
              look in the instance and if it can't be found the runtime will
              search the class and all it's parent classes. Here is an example:
            </p>
            <pre><code>class Root : Object {
	var value0 = 0;
	var value1 = 1;
}

class Child : Root {
	var value0 = false;
}

class GrandChild : Child {
	var value2 = 2;
	var value3 = 3;
}

var grandChild = GrandChild();
grandChild.value3 = true;

assert(grandChild.value0 == false);
assert(grandChild.value1 == 1);
assert(grandChild.value2 == 2);
assert(grandChild.value3 == true);
</code></pre>
            <p>
              When setting a member, the dot notation can be used to set
              instance and class members like:
            </p>
            <pre><code>grandChild.age = 5; // setting an instance member
GrandChild.value3 = null; // setting a class member;
</code></pre>
            <p><strong>Member Functions</strong></p>
            <p>
              Member functions are associated with classes and encapsulate
              specific tasks and functionality for working with an instance of a
              given class.
            </p>
            <p>
              You write an member functions within the opening and closing
              braces of the class they belongs to. A member function can be
              called only on a specific instance of the class it belongs to.
            </p>
            <p>
              Here’s an example that defines a simple Counter class, which can
              be used to count the number of times an action occurs:
            </p>
            <pre><code>class Counter : Object {
	function__init__(this) {
		this.count = 0;
	}

	function increment(this) {
		this.count += 1;
	}

	function increment(this, amount) {
		this.count += amount;
	}

	function reset(this) {
		this.count = 0;
	}
}
</code></pre>
            <p>The Counter class defines three instance methods:</p>
            <ul>
              <li>increment(this) - increments the counter by 1.</li>
              <li>
                increment(this, amount) - increments the counter by a specified
                amount.
              </li>
              <li>reset(this) - resets the counter to zero.</li>
            </ul>
            <p>
              You call instance methods with the same dot syntax as properties:
            </p>
            <pre><code>var counter = Counter(); // the initial counter value is 0
counter.increment();     // the counter's value is now 1
counter.increment(5);    // the counter's value is now 6
counter.reset();         // the counter's value is now 0
</code></pre>
            <p><strong>The this Property</strong></p>
            <p>
              Notice in the examples above how &quot;this&quot; is used to
              distinguish the name property from the name argument to the
              initializer. In some computer language, the &quot;this&quot; or
              &quot;self&quot; argument is automatically added to a member
              function. In ObjectTalk this is not the case and you have to name
              it yourself as the first parameter of a member function. The
              benefit is that you can call it whatever you want and it's not
              some hidden feature of the language. The disadvantage is that you
              have to type it for every member function. The compiler
              automatically translates a bound function (a function in the
              context of an object) to a new function call with an additional
              parameter.
            </p>
            <pre><code>counter.increment(2); // becomes:
Counter.increment(counter, 2);
</code></pre>
            <p><strong>Constructor</strong></p>
            <p>
              Initialization is the process of preparing an instance of a class
              for use and it's performed by the class' constructor. This process
              involves setting an initial value for member variables on that
              instance and performing any other setup or initialization that’s
              required before the new instance is ready for use.
            </p>
            <p>
              You implement this initialization process by defining
              constructors, which are like special member functions that can be
              called to create a new instance of a particular type. Their
              primary role is to ensure that new instances of a type are
              correctly initialized before they’re used for the first time.
            </p>
            <p>
              The name of the constructor is always <strong>__init__</strong> as
              you can see in the examples above. Here's another example:
            </p>
            <pre><code>class Fahrenheit : Object {
	function __init__(this) {
		this.temperature = 32;
	}
}

var f = Fahrenheit();
print(&quot;The default temperature is &quot;, f.temperature, &quot;° Fahrenheit&quot;)
// Prints &quot;The default temperature is 32° Fahrenheit&quot;
</code></pre>
            <p>
              In case the class is derived from a class that also has a
              constructor, the superclass constructor must also be called like
              this:
            </p>
            <pre><code>class Temperature : Object {
	function __init__(this) {
		this.measurement = &quot;temperature&quot;;
	}
}

class Fahrenheit : Temperature {
	function __init__(this) {
		super.__init__(this);
		this.temperature = 32;
	}
}
</code></pre>
            <p><strong>Operators</strong></p>
            <p>
              In ObjectTalk, everything is an Object derived from a Class. The
              number 1 is an object derived from the Integer class and so are
              3.14 (derived from the Real class) and &quot;test&quot; (derived
              from the string class). To take this a step further, operators
              like +, -, *, /, [] and () are actually member functions of a
              class.
            </p>
            <p>
              To ensure this doesn't lead to silly syntax, the ObjectTalk
              compiler translates more traditional expressions into a set of
              member function calls. So for instances, the follow example shows
              this translation:
            </p>
            <pre><code>1 + (2 * 3)

2.__mul__(3).__add__(1)
</code></pre>
            <p>
              As a user of ObjectTalk you only have to learn the top syntax. If
              you want to understand the compiler and VM, you have to understand
              both.
            </p>
            <p>
              Given that operators become member function calls, custom Classes
              can implement operators so it is very simple in ObjectTalk to
              implement a Vector class that implements a dot product operator.
            </p>
            <p>
              You can find a list of all operator function member name in the
              <a class="page-scroll" href="#operators">Operators</a> section.
            </p>
            <p><strong>Subclassing</strong></p>
            <p>
              You can subclass any class as ObjectTalk supports the concept of
              single inheritance (meaning a class can derive from a single other
              class). In fact all classes in ObjectTalk have a parent class with
              the exception of the <strong>Object</strong> class which is the
              root class for all others.
            </p>
            <pre><code>class A : Object {
	function someMethod(this) {
		print(&quot;A.someMethod()&quot;);
	}
}

class B : A {
	function someMethod(this) {
		print(&quot;B.someMethod()&quot;);
	}
}
</code></pre>
            <p>
              It’s valid for a subclass member to call a superclass member using
              the <strong>super</strong> special keyword.
            </p>
            <pre><code>class A : Object {
	function someMethod(this, value) {
		print(&quot;A.someMethod(&quot;, value, &quot;)&quot;);
	}
}

class B : A {
	function someMethod(this, value) {
		super.someMethod(this, value);
		print(&quot;B.someMethod(&quot;, value, &quot;)&quot;);
	}
}

var b = B();
b.someMethod(2);
</code></pre>
            <p>
              Please note that the <strong>super</strong> mechanism can only be
              used in a class definition and it is basically a shortcut to the
              superclass' specified member function. As such, the resulting
              reference is unbound and you have to pass the target object as the
              first parameter in the member function call.
            </p>
            <p>
              In the above example <strong>b.someMethod(2)</strong> is
              translated into a bound member function call and
              <strong>someMethod</strong> is called with <strong>b</strong> and
              <strong>2</strong> as parameters.
              <strong>super.someMethod</strong> is an unbound member function
              call and you will have to pass the object.
            </p>
          </div>
          <div id="functions">
            <h1 class="pb-2">Functions</h1>
            <p>
              Functions are self-contained chunks of code that perform a
              specific task. ObjectTalk has three function &quot;types&quot;.
              First there is the traditional function as you would define it in
              other languages. Secondly there is the &quot;lambda&quot; version
              of a function which makes a function look more like any other
              primitive. In fact, the only difference between these first two
              types is syntax. The third type is the member function which is a
              function attached to a class and performs a task on an instance of
              that class. This is what they looks like:
            </p>
            <pre><code>// traditional function definition
function callMeTraditional(parameter) {
	return parameter + 1;
}

// &quot;lambda&quot; style function
var callMeLambda = function(parameter) {
	return parameter + 1;
}

// member function
class newestObjectClass : Object {
	var increment = 1;

	function callMeMemberFunction(this, parameter) {
		return parameter + this.increment;
	}
}
</code></pre>
            <p>
              Traditional and lambda functions will be described in this
              section. Member Functions are covered in the
              <a class="page-scroll" href="#classes">Classes</a> section.
            </p>
            <p>
              When you define a function, you can optionally define one or more
              named, values that the function takes as input, known as
              parameters. Function parameters and return values are extremely
              flexible in ObjectTalk. You can define anything from a simple
              utility function with a single parameter to a complex function
              with expressive parameters.
            </p>
            <p><strong>Functions Without Parameters</strong></p>
            <p>
              Functions aren’t required to define input parameters. Here’s a
              function with no input parameters, which always returns the same
              String message whenever it’s called:
            </p>
            <pre><code>function sayHelloWorld() {
	return &quot;hello, world&quot;;
}

print(sayHelloWorld());
// Prints &quot;hello, world&quot;
</code></pre>
            <p>
              The function definition still needs parentheses after the
              function’s name, even though it doesn’t take any parameters. The
              function name is also followed by an empty pair of parentheses
              when the function is called.
            </p>
            <p><strong>Functions With Multiple Parameters</strong></p>
            <p>
              Functions can have multiple input parameters, which are written
              within he function’s parentheses, separated by commas.
            </p>
            <p>
              This function takes a person’s name and whether they have already
              been greeted as input, and returns an appropriate greeting for
              that person:
            </p>
            <pre><code>function greet(person, alreadyGreeted) {
	if (alreadyGreeted) {
		return greetAgain(person);

	} else {
		return greet(person);
	}
}

print(greet(&quot;Tim&quot;, true));
// Prints &quot;Hello again, Tim!&quot;
</code></pre>
            <p><strong>Functions Without Return Values</strong></p>
            <p>
              Functions aren’t required to return a value. Here’s a version of
              the greet function, which prints its own String value rather than
              returning it:
            </p>
            <pre><code>function greet(person) {
	print(&quot;Hello, &quot;, person, &quot;!&quot;);
}

greet(&quot;Dave&quot;);
// Prints &quot;Hello, Dave!&quot;
</code></pre>
            <p>
              Strictly speaking, this version of the greet() function does still
              return a value, even though no return value is defined. Functions
              without a defined return will automatically return
              <strong>null</strong>.
            </p>
            <p><strong>Functions as Return Value</strong></p>
            <p>
              You can use a function as the return value of another function.
              The next example defines two simple functions called stepForward()
              and stepBackward(). The stepForward() function returns a value one
              more than its input value, and the stepBackward() function returns
              a value one less than its input value.
            </p>
            <pre><code>function stepForward(input) {
	return input + 1;
}

function stepBackward(input) {
	return input - 1;
}
</code></pre>
            <p>
              Here’s a function called chooseStepFunction() which returns the
              stepForward() function or the stepBackward() function based on a
              Boolean arameter called backward:
            </p>
            <pre><code>function chooseStepFunction(backward) {
	return backward ? stepBackward : stepForward;
}
</code></pre>
            <p>
              You can now use chooseStepFunction() to obtain a function that
              will step in one direction or the other:
            </p>
            <pre><code>var currentValue = 3;
var moveNearerToZero = chooseStepFunction(currentValue &gt; 0);
// moveNearerToZero now refers to the stepBackward() function
</code></pre>
            <p>
              The example above determines whether a positive or negative step
              is needed to move a variable called currentValue progressively
              closer to zero. currentValue has an initial value of 3, which
              means that currentValue &gt; 0 returns true, causing
              chooseStepFunction(backward:) to return the stepBackward()
              function. A reference to the returned function is stored in a
              constant called moveNearerToZero.
            </p>
            <p>
              Now that moveNearerToZero refers to the correct function, it can
              be used to count to zero:
            </p>
            <pre><code>print(&quot;Counting to zero:&quot;);

// Counting to zero:
while (currentValue != 0) {
	print(currentValue, &quot;... &quot;);
	currentValue = moveNearerToZero(currentValue);
}

print(&quot;zero!&quot;);
// 3...
// 2...
// 1...
// zero!
</code></pre>
            <p><strong>Nested Functions</strong></p>
            <p>
              All of the functions you have encountered so far in this chapter
              have been examples of global functions, which are defined at a
              global or module scope. You can also define functions inside the
              bodies of other functions, known as nested functions.
            </p>
            <p>
              Nested functions are hidden from the outside world by default, but
              can still be called and used by their enclosing function. An
              enclosing function can also return one of its nested functions to
              allow the nested function to be used in another scope.
            </p>
            <p>
              You can rewrite the chooseStepFunction() example above to use and
              return nested functions:
            </p>
            <pre><code>function chooseStepFunction(backward) {
	function stepForward(input) { return input + 1 }
	function stepBackward(input) { return input - 1 }
	return backward ? stepBackward : stepForward;
}

var currentValue = -4;
var moveNearerToZero = chooseStepFunction(currentValue &gt; 0);

// moveNearerToZero now refers to the nested stepForward() function
while (currentValue != 0) {
	print(currentValue, &quot;...&quot;);
	currentValue = moveNearerToZero(currentValue);
}

print(&quot;zero!&quot;);

// -4...
// -3...
// -2...
// -1...
// zero!
</code></pre>
          </div>
        </div>
      </div>
      <div class="row flex-shrink-0 py-1 manual-footer" id="copyright">
        <p class="mx-auto py-0 my-0 small">
          Copyright (c) 1993-2023 Johan A. Goossens. All rights reserved.
        </p>
      </div>
    </div>
    <script src="js/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/jquery.easing.min.js"></script>
    <script src="js/theme.js"></script>
  </body>
</html>
