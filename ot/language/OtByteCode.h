//	ObjectTalk Scripting Language
//	Copyright (c) 1993-2024 Johan A. Goossens. All rights reserved.
//
//	This work is licensed under the terms of the MIT license.
//	For a copy, see <https://opensource.org/licenses/MIT>.



#pragma once


//
//	Include files
//

#include <algorithm>
#include <cstdint>
#include <string>
#include <string_view>
#include <utility>
#include <vector>

#include "OtException.h"
#include "OtInternal.h"
#include "OtObject.h"
#include "OtSource.h"
#include "OtStatement.h"
#include "OtSymbol.h"


//
//	Forward declarations
//

class OtMemberReferenceClass;
using OtMemberReference = OtObjectPointer<OtMemberReferenceClass>;

class OtStackReferenceClass;
using OtStackReference = OtObjectPointer<OtStackReferenceClass>;


//
//	OtByteCode
//

class OtByteCodeClass;
using OtByteCode = OtObjectPointer<OtByteCodeClass>;

class OtByteCodeClass : public OtInternalClass {
public:
	// possible opcodes
	typedef enum {
		// opcodes generated by the compiler
		statementOpcode,
		pushOpcode,
		pushNullOpcode,
		popOpcode,
		popCountOpcode,
		dupOpcode,
		swapOpcode,
		moveOpcode,
		jumpOpcode,
		jumpTrueOpcode,
		jumpFalseOpcode,
		memberOpcode,
		superOpcode,
		methodOpcode,
		exitOpcode,
		reserveOpcode,
		pushTryOpcode,
		popTryOpcode,

		// opcodes generated by the optimizer
		pushStackOpcode,
		pushObjectMemberOpcode,
		pushMemberOpcode,
		assignStackOpcode,
		assignMemberOpcode
	} OtOpcode;

	// constructors
	OtByteCodeClass() = default;
	OtByteCodeClass(OtSource s, const std::string& n) : source(s), name(n) {}

	// add compiler opcodes
	inline void statement() { emitOpcode(statementOpcode); }
	inline void push(OtObject value) { emitOpcode(pushOpcode); emitConstant(value); }
	inline void pushNull() { emitOpcode(pushNullOpcode); }
	inline void pop() { emitOpcode(popOpcode); }
	inline void pop(size_t count) { emitOpcode(popCountOpcode); emitNumber(count); }
	inline void dup() { emitOpcode(dupOpcode); }
	inline void swap() { emitOpcode(swapOpcode); }
	inline void move(size_t count) { emitOpcode(moveOpcode); emitNumber(count); }
	inline size_t jump(size_t offset) { emitOpcode(jumpOpcode); return emitJump(offset); }
	inline size_t jumpTrue(size_t offset) { emitOpcode(jumpTrueOpcode); return emitJump(offset); }
	inline size_t jumpFalse(size_t offset) { emitOpcode(jumpFalseOpcode); return emitJump(offset); }
	inline void member(size_t id) { emitOpcode(memberOpcode); emitNumber(id); }
	inline void member(const char* name) { emitOpcode(memberOpcode); emitSymbol(name); }
	inline void member(const std::string_view name) { emitOpcode(memberOpcode); emitSymbol(name); }
	inline void member(const std::string& name) { emitOpcode(memberOpcode); emitSymbol(name); }
	inline void method(size_t id, size_t count) { emitOpcode(methodOpcode); emitNumber(id); emitNumber(count); }
	inline void method(const char* name, size_t count) { emitOpcode(methodOpcode); emitSymbol(name); emitNumber(count); }
	inline void method(const std::string_view name, size_t count) { emitOpcode(methodOpcode); emitSymbol(name); emitNumber(count); }
	inline void method(const std::string& name, size_t count) { emitOpcode(methodOpcode); emitSymbol(name); emitNumber(count); }
	inline void super(size_t id) { emitOpcode(superOpcode); emitNumber(id); }
	inline void super(const char* name) { emitOpcode(superOpcode); emitSymbol(name); }
	inline void super(const std::string_view name) { emitOpcode(superOpcode); emitSymbol(name); }
	inline void super(const std::string& name) { emitOpcode(superOpcode); emitSymbol(name); }
	inline void exit() { emitOpcode(exitOpcode); }
	inline void reserve() { emitOpcode(reserveOpcode); }
	inline size_t pushTry() { emitOpcode(pushTryOpcode); return emitJump(0); }
	inline void pushTry(size_t offset) { emitOpcode(pushTryOpcode); emitJump(offset); }
	inline void popTry() { emitOpcode(popTryOpcode); }

	// patch jump offset
	inline void patchJump(size_t jump) { jumps[jump] = bytecode.size(); }

	// add optimizer opcodes
	inline void pushStack(size_t slot) { emitOpcode(pushStackOpcode); emitNumber(slot); }
	inline void pushObjectMember(OtObject object, size_t member) { emitOpcode(pushObjectMemberOpcode); emitConstant(object); emitNumber(member); }
	inline void pushMember(const size_t member) { emitOpcode(pushMemberOpcode); emitNumber(member); }
	inline void assignStack(size_t slot) { emitOpcode(assignStackOpcode); emitNumber(slot); }
	inline void assignMember(OtObject object, size_t member) { emitOpcode(assignMemberOpcode); emitConstant(object); emitNumber(member); }

	// get current code size
	inline size_t size() { return bytecode.size(); }

	// get opcode
	inline uint8_t getOpcode(size_t& pc) {
		return bytecode[pc++];
	}

	// get variable length number
	inline size_t getNumber(size_t& pc) {
		size_t result = 0;
		size_t shift = 0;

		while (true) {
			auto byte = bytecode[pc++];
			result |= size_t(byte & 0x7f) << shift;

			if (!(byte & 0x80)) {
				break;
			}

			shift += 7;
		}

		return result;
	}

	// disassemble the bytecode
	std::string disassemble();

	// copy from other bytecode
	void copyOpcode(OtByteCode bytecode, size_t pc);

	// add statement reference
	inline void addStatement(size_t sourceStart, size_t sourceEnd, size_t opcodeStart, size_t opcodeEnd) {
		statements.emplace_back(sourceStart, sourceEnd, opcodeStart, opcodeEnd);
	}

	// declare a new symbol located on the heap
	inline void declareSymbol(size_t id, OtObject object) {
		symbols.emplace_back(id, object, bytecode.size(), true);
	}

	// declare a new symbol located on the stack
	inline void declareSymbol(size_t id, size_t slot) {
		symbols.emplace_back(id, slot, bytecode.size(), true);
	}

	// reference a symbol located on the heap
	inline void referenceSymbol(size_t id, OtObject object) {
		symbols.emplace_back(id, object, bytecode.size(), false);
	}

	// reference a symbol located on the stack
	inline void referenceSymbol(size_t id, size_t slot) {
		symbols.emplace_back(id, slot, bytecode.size(), false);
	}

	// end visibility of specified symbol
	inline void hideSymbol(size_t id) {
		lookupSymbol(id)->opcodeEnd = bytecode.size();
	}

	// see if symbol is known
	inline bool hasSymbol(size_t id) {
		return lookupSymbol(id) != symbols.rend();
	}

	// see if symbol is declared
	inline bool isSymbolDeclared(size_t id) {
		auto i = lookupSymbol(id);
		return i != symbols.rend() && i->declared;
	}

	// get code parts
	inline std::string getModule() { return source->getModule(); }
	inline OtSource& getSource() { return source; }
	inline std::string& getName() { return name; }
	inline uint8_t* getCode() { return bytecode.data(); }
	inline OtObject& getConstant(size_t index) { return constants[index]; }
	inline std::vector<size_t>& getJumps() { return jumps; }
	inline size_t getJump(size_t jump) { return jumps[jump]; }
	inline std::vector<OtStatement>& getStatements() { return statements; }
	inline std::vector<OtSymbol>& getSymbols() { return symbols; }

	// bytecode introspection
	size_t getOpcodeSize(size_t pc);

	bool isPush(size_t pc, OtObject& object);
	bool isPushStackReference(size_t pc, OtStackReference& reference);
	bool isPushMemberReference(size_t pc, OtMemberReference& reference);
	bool isSwap(size_t pc);
	bool isMember(size_t pc, size_t& member);
	bool isMethodDeref(size_t pc);
	bool isMethodAssign(size_t pc);
	bool isAnyJump(size_t pc, size_t& offset);

	size_t getStatementStart(size_t pc);
	size_t getStatementEnd(size_t pc);
	size_t getLineNumber(size_t pc);
	std::string getStatementSourceCode(size_t pc);

	// get type definition
	static OtType getMeta();

private:
	// emit parts to bytecode
	inline void emitOpcode(OtOpcode opcode) {
		bytecode.emplace_back((uint8_t) opcode);
	}

	inline void emitConstant(OtObject constant) {
		auto index = constants.size();
		constants.emplace_back(constant);
		emitNumber(index);
	}

	inline void emitSymbol(const char* name) {
		emitNumber(OtIdentifier::create(name));
	}

	inline void emitSymbol(const std::string_view name) {
		emitNumber(OtIdentifier::create(name));
	}

	inline void emitSymbol(const std::string& name) {
		emitNumber(OtIdentifier::create(name));
	}

	inline size_t emitJump(size_t offset) {
		auto jump = jumps.size();
		jumps.emplace_back(offset);
		emitNumber(jump);
		return jump;
	}

	inline void emitNumber(size_t number) {
		while (number > 0x7f) {
			bytecode.emplace_back(((uint8_t)(number & 0x7f)) | 0x80);
			number >>= 7;
		}

		bytecode.emplace_back((uint8_t) number);
	}

	// lookup a symbol
	inline std::vector<OtSymbol>::reverse_iterator lookupSymbol(size_t id) {
		return std::find_if(symbols.rbegin(), symbols.rend(), [id](const OtSymbol& symbol){
			return symbol.id == id && !symbol.opcodeEnd;
		});
	}

	OtSource source;
	std::string name;
	std::vector<uint8_t> bytecode;
	std::vector<OtObject> constants;
	std::vector<size_t> jumps;
	std::vector<OtStatement> statements;
	std::vector<OtSymbol> symbols;
};
