//	ObjectTalk Scripting Language
//	Copyright (c) 1993-2024 Johan A. Goossens. All rights reserved.
//
//	This work is licensed under the terms of the MIT license.
//	For a copy, see <https://opensource.org/licenses/MIT>.


//
//	Include files
//

#include <string>

#include "fmt/format.h"

#include "OtAssert.h"
#include "OtClass.h"
#include "OtException.h"
#include "OtFunction.h"
#include "OtLog.h"
#include "OtMemberReference.h"
#include "OtIdentifier.h"
#include "OtString.h"
#include "OtVM.h"


//
//	OtTryCatch
//

class OtTryCatch {
public:
	OtTryCatch(size_t p, OtStackState s) : pc(p), stack(s) {}
	size_t pc;
	OtStackState stack;
};


//
//	OtVM::execute
//

OtObject OtVM::execute(OtByteCode bytecode, size_t callingParameters) {
	// try/catch stack
	std::vector<OtTryCatch> tryCatch;

	// local variables
	size_t pc = 0;
	size_t sp = stack.size();
	size_t end = bytecode->size();

	// open a new stack frame
	stack.openFrame(bytecode, callingParameters, &pc);

	// save the current stack state (so we can restore it in case of an uncaught exception)
	OtStackState state = stack.getState();

	// execute all instructions
	while (pc < end) {
		try {
			switch (bytecode->getOpcode(pc)) {

				// opcodes generated by the compiler

				case OtByteCodeClass::statementOpcode:
					// call statement hook (if required)
					if (callHook) {
						statementHook();
					}

					break;

				case OtByteCodeClass::pushOpcode:
					// push an object onto the stack
					stack.push(bytecode->getConstant(bytecode->getNumber(pc)));
					break;

				case OtByteCodeClass::pushNullOpcode:
					// push null object onto the stack
					stack.push(null);
					break;

				case OtByteCodeClass::popOpcode:
					// pop an object from the stack
					stack.pop();
					break;

				case OtByteCodeClass::popCountOpcode:
					// pop specified number of objects from the stack
					stack.pop(bytecode->getNumber(pc));
					break;

				case OtByteCodeClass::dupOpcode:
					// duplicate top object on the stack
					stack.dup();
					break;

				case OtByteCodeClass::swapOpcode:
					// swap the top two objects on the stack
					stack.swap();
					break;

				case OtByteCodeClass::moveOpcode:
					// move the top stack object back a specifed number of slots
					stack.move(bytecode->getNumber(pc));
					break;

				case OtByteCodeClass::jumpOpcode:
					// jump to the specified bytecode location
					pc = bytecode->getJump(bytecode->getNumber(pc));
					break;

				case OtByteCodeClass::jumpTrueOpcode: {
					// jump to the specified bytecode location if the top stack object is true
					auto jump = bytecode->getJump(bytecode->getNumber(pc));
					auto value = stack.pop();

					if (value->operator bool()) {
						pc = jump;
					}

					break;
				}

				case OtByteCodeClass::jumpFalseOpcode: {
					// jump to the specified bytecode location if the top stack object is false
					auto jump = bytecode->getJump(bytecode->getNumber(pc));
					auto value = stack.pop();

					if (!value->operator bool()) {
						pc = jump;
					}

					break;
				}

				case OtByteCodeClass::memberOpcode: {
					// create an object member reference
					auto object = stack.pop();
					auto member = bytecode->getID(pc);
					auto reference = OtMemberReference::create(object, member);
					stack.push(reference);
					break;
				}

				case OtByteCodeClass::superOpcode: {
					// get a specifed member in a superclass
					auto cls = OtClass(stack.pop());
					auto member = bytecode->getID(pc);
					auto result = cls->getSuper(member);
					stack.push(result);
					break;
				}

				case OtByteCodeClass::methodOpcode: {
					// call a method on a specified object
					// get method and number of calling parameters
					auto method = bytecode->getID(pc);
					auto count = bytecode->getNumber(pc);

					// get a pointer to the calling parameters and target object
					auto parameters = stack.sp(count + 1);

					// sanity check
					if (!parameters[0]) {
						OtLogFatal("Internal error: can't call method [{}] with [{}] parameters on nullptr", OtIdentifier::name(method), count);
					}

					// call method
					auto result = parameters[0]->get(method)->operator () (count + 1, parameters);

					// remove arguments from stack and put result back on it
					stack.pop(count + 1);
					stack.push(result ? result : null);
					break;
				}

				case OtByteCodeClass::exitOpcode:
					// exit instructions
					pc = end;
					break;

				case OtByteCodeClass::reserveOpcode:
					// reserve a new slot on the stack
					stack.reserve();
					break;

				case OtByteCodeClass::pushTryOpcode:
					// start a new try/catch cycle
					tryCatch.push_back(OtTryCatch(bytecode->getJump(bytecode->getNumber(pc)), stack.getState()));
					break;

				case OtByteCodeClass::popTryOpcode:
					// start a new try/catch cycle
					tryCatch.pop_back();
					break;

				// opcodes generated by the optimizer

				case OtByteCodeClass::pushStackOpcode: {
					// push a stack-based object back onto the stack
					auto slot = bytecode->getNumber(pc);
					auto object  = stack.getFrameItem(OtStackItem(0, slot));
					stack.push(object);
					break;
				}

				case OtByteCodeClass::pushObjectMemberOpcode: {
					// push a constant object member onto the stack
					auto object = bytecode->getConstant(bytecode->getNumber(pc));
					auto member = bytecode->getID(pc);
					auto resolvedMember = OtMemberReferenceClass::resolveMember(object, member);
					stack.push(resolvedMember);
					break;
				}
				case OtByteCodeClass::pushMemberOpcode: {
					// push a heap-based object member onto the stack
					auto object = stack.pop();
					auto member = bytecode->getID(pc);
					auto resolvedMember = OtMemberReferenceClass::resolveMember(object, member);
					stack.push(resolvedMember);
					break;
				}

				case OtByteCodeClass::assignStackOpcode: {
					// put the top stack object into a stack-based slot
					auto slot = bytecode->getNumber(pc);
					auto value = stack.back();
					stack.setFrameItem(OtStackItem(0, slot), value);
					break;
				}

				case OtByteCodeClass::assignMemberOpcode: {
					// put the top stack object into a heap-based object member
					auto object = bytecode->getConstant(bytecode->getNumber(pc));
					auto member = bytecode->getID(pc);
					auto value = stack.back();
					object->set(member, value);
					break;
				}
			}

		} catch (const OtException& e) {
			// do we have an exception handler
			if (tryCatch.size()) {
				// yes, use it
				OtTryCatch trycatch = tryCatch.back();
				tryCatch.pop_back();

				// restore program counter and stack
				pc = trycatch.pc;
				stack.restoreState(trycatch.stack);

				// put exception on the stack
				auto message = OtString::create(e.what());
				stack.push(message);

			} else {
				// format long message
				auto fullMessage = fmt::format(
					"{}\nModule: {}\n{}",
					e.what(),
					bytecode->getModule(),
					bytecode->getStatementSourceCode(pc));

				// restore the stack state
				stack.restoreState(state);
				stack.closeFrame();

				// throw exception
				if (e.getLineNumber()) {
					throw OtException(
						e.getModule(),
						e.getLineNumber(),
						e.getStart(),
						e.getEnd(),
						e.what(),
						fullMessage);

				} else {
					throw OtException(
						bytecode->getModule(),
						bytecode->getLineNumber(pc),
						bytecode->getStatementStart(pc),
						bytecode->getStatementEnd(pc),
						e.what(),
						fullMessage);
				}
			}
		}
	}

	// get result
	auto result = stack.pop();

	// close the stack frame
	stack.closeFrame();

	// sanity check
	OtAssert(tryCatch.size() == 0);
	OtAssert(stack.size() == sp);

	// return execution result
	return result;
}
